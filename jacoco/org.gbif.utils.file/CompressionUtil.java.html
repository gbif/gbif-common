<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompressionUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GBIF Common</a> &gt; <a href="index.source.html" class="el_package">org.gbif.utils.file</a> &gt; <span class="el_source">CompressionUtil.java</span></div><h1>CompressionUtil.java</h1><pre class="source lang-java linenums">/*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gbif.utils.file;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.zip.GZIPInputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.io.filefilter.HiddenFileFilter;
import org.apache.commons.io.filefilter.TrueFileFilter;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class CompressionUtil {

<span class="nc" id="L53">  private CompressionUtil() {</span>
<span class="nc" id="L54">    throw new UnsupportedOperationException(&quot;Can't initialize class&quot;);</span>
  }

  public static class UnsupportedCompressionType extends RuntimeException {

<span class="nc" id="L59">    public UnsupportedCompressionType() {}</span>

    public UnsupportedCompressionType(String message) {
<span class="nc" id="L62">      super(message);</span>
<span class="nc" id="L63">    }</span>

    public UnsupportedCompressionType(String message, Throwable cause) {
<span class="nc" id="L66">      super(message, cause);</span>
<span class="nc" id="L67">    }</span>
  }

<span class="fc" id="L70">  private static final Logger LOG = LoggerFactory.getLogger(CompressionUtil.class);</span>
  private static final int BUFFER = 2048;
  private static final String APPLE_RESOURCE_FORK = &quot;__MACOSX&quot;;
<span class="fc" id="L73">  private static final byte[] TAR_MAGIC_BYTES = new byte[] {'u', 's', 't', 'a', 'r'};</span>

  /**
   * Tries to decompress a file into a newly created temporary directory, trying gzip or zip regardless of the filename
   * or its suffix.
   *
   * @return folder containing all decompressed files
   */
  public static File decompressFile(File compressedFile)
      throws IOException, UnsupportedCompressionType {
    // create empty tmp dir
<span class="nc" id="L84">    File dir = File.createTempFile(&quot;gbif-&quot;, null);</span>
<span class="nc bnc" id="L85" title="All 4 branches missed.">    if (dir.exists() &amp;&amp; !dir.delete()) {</span>
<span class="nc" id="L86">      throw new IOException(&quot;Couldn't delete temporary directory&quot;);</span>
    }

<span class="nc bnc" id="L89" title="All 2 branches missed.">    if (!dir.mkdirs()) {</span>
<span class="nc" id="L90">      throw new IOException(&quot;Couldn't create temporary directory for decompression&quot;);</span>
    }

    // decompress
<span class="nc" id="L94">    decompressFile(dir, compressedFile);</span>

<span class="nc" id="L96">    return dir;</span>
  }

  /**
   * Defaults keeping subDirectories to false.
   *
   * @see org.gbif.utils.file.CompressionUtil#decompressFile(java.io.File, java.io.File, boolean)
   */
  public static List&lt;File&gt; decompressFile(File directory, File compressedFile)
      throws IOException, UnsupportedCompressionType {
<span class="fc" id="L106">    return decompressFile(directory, compressedFile, false);</span>
  }

  /**
   * Tries to decompress a file using TAR+gzip, TAR or Zip regardless of the filename or its suffix.
   *
   * @param directory      directory where archive's contents will be decompressed to
   * @param compressedFile compressed file
   *
   * @return list of files that have been extracted or null an empty list if archive couldn't be decompressed
   *
   * @throws IOException                if problem occurred reading compressed file, or directory couldn't be written
   *                                    to
   * @throws UnsupportedCompressionType if the compression type wasn't recognized
   */
  public static List&lt;File&gt; decompressFile(
      File directory, File compressedFile, boolean keepSubdirectories)
      throws IOException, UnsupportedCompressionType {
<span class="fc" id="L124">    List&lt;File&gt; files = null;</span>

    // Test before trying gzip format
<span class="fc bfc" id="L127" title="All 2 branches covered.">    if (isGzipFormat(compressedFile)) {</span>
      try {
<span class="fc" id="L129">        LOG.debug(&quot;Uncompressing {} with gzip compression to {}&quot;, compressedFile, directory);</span>
<span class="fc" id="L130">        files = untgzFile(directory, compressedFile);</span>
<span class="nc" id="L131">      } catch (Exception e) {</span>
<span class="nc" id="L132">        LOG.debug(&quot;Not gzip compression&quot;);</span>
<span class="fc" id="L133">      }</span>
    }

    // Test before trying TAR format
<span class="fc bfc" id="L137" title="All 2 branches covered.">    if (isTarFormat(compressedFile)) {</span>
      try {
<span class="fc" id="L139">        LOG.debug(&quot;Uncompressing {} with TAR compression to {}&quot;, compressedFile, directory);</span>
<span class="fc" id="L140">        files = untarFile(directory, compressedFile);</span>
<span class="nc" id="L141">      } catch (Exception e) {</span>
<span class="nc" id="L142">        LOG.debug(&quot;Not TAR compression&quot;);</span>
<span class="fc" id="L143">      }</span>
    }

    // Then try zip
<span class="fc bfc" id="L147" title="All 2 branches covered.">    if (files == null) {</span>
      try {
<span class="fc" id="L149">        LOG.debug(&quot;Uncompressing {} with Zip compression to {}&quot;, compressedFile, directory);</span>
<span class="fc" id="L150">        files = unzipFile(directory, compressedFile, keepSubdirectories);</span>
<span class="nc" id="L151">      } catch (ZipException e) {</span>
<span class="nc" id="L152">        LOG.debug(&quot;Not Zip compression&quot;);</span>
<span class="nc" id="L153">        throw new UnsupportedCompressionType(&quot;Unknown compression type. Neither gzip nor Zip&quot;, e);</span>
<span class="fc" id="L154">      }</span>
    }

<span class="fc bfc" id="L157" title="All 2 branches covered.">    if (files.isEmpty()) {</span>
<span class="fc" id="L158">      LOG.warn(&quot;No files extracted from {}, tried TGZ, TAR and Zip compression.&quot;, compressedFile);</span>
    }

<span class="fc" id="L161">    return files;</span>
  }

  /**
   * Check the file's first two bytes, to see if they are the gzip magic number.
   * @param compressedFile compressed file
   * @return               true if the file is in gzip format
   * @throws IOException   if a problem occurred reading compressed file
   */
  private static boolean isGzipFormat(File compressedFile) throws IOException {
<span class="fc" id="L171">    try (RandomAccessFile file = new RandomAccessFile(compressedFile, &quot;r&quot;)) {</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">      return GZIPInputStream.GZIP_MAGIC == (file.read() &amp; 0xff | ((file.read() &lt;&lt; 8) &amp; 0xff00));</span>
    }
  }

  /**
   * Check the file is a Tape ARchive (TAR).
   * @param compressedFile compressed file
   * @return               true if the file is a TAR
   * @throws IOException   if a problem occurred reading compressed file
   */
  private static boolean isTarFormat(File compressedFile) throws IOException {
<span class="fc" id="L183">    try (RandomAccessFile file = new RandomAccessFile(compressedFile, &quot;r&quot;)) {</span>
      // TAR files contain &quot;ustar\0&quot; or &quot;ustar &quot; at byte 257.
      // https://www.gnu.org/software/tar/manual/html_node/Standard.html
<span class="fc" id="L186">      byte[] at257 = new byte[5];</span>
<span class="fc" id="L187">      file.seek(257);</span>
<span class="fc" id="L188">      file.read(at257, 0, 5);</span>
<span class="fc" id="L189">      return Arrays.equals(at257, TAR_MAGIC_BYTES);</span>
<span class="nc" id="L190">    } catch (Exception e) {</span>
<span class="nc" id="L191">      LOG.debug(&quot;Exc&quot;, e);</span>
    }
<span class="nc" id="L193">    return false;</span>
  }

  /**
   * Extracts a gzipped TAR file. Directory structure and hidden files (i.e. files starting with a dot) are ignored.
   *
   * @param directory where the file should be extracted to
   * @param tgzFile   to extract
   *
   * @return a list of all created files
   */
  public static List&lt;File&gt; untgzFile(File directory, File tgzFile) throws IOException {
<span class="fc" id="L205">    return untarStream(directory, new GZIPInputStream(new FileInputStream(tgzFile)));</span>
  }

  /**
   * Extracts a plain TAR file. Directory structure and hidden files (i.e. files starting with a dot) are ignored.
   *
   * @param directory where the file should be extracted to
   * @param tarFile   to extract
   *
   * @return a list of all created files
   */
  public static List&lt;File&gt; untarFile(File directory, File tarFile) throws IOException {
<span class="fc" id="L217">    return untarStream(directory, new FileInputStream(tarFile));</span>
  }

  /**
   * Extracts a TAR stream. Directory structure and hidden files (i.e. files starting with a dot) are ignored.
   *
   * @param directory where the file should be extracted to
   * @param tarStream to extract
   *
   * @return a list of all created files
   */
  private static List&lt;File&gt; untarStream(File directory, InputStream tarStream) throws IOException {
<span class="fc" id="L229">    List&lt;File&gt; files = new ArrayList&lt;File&gt;();</span>
<span class="fc" id="L230">    try (TarArchiveInputStream in = new TarArchiveInputStream(tarStream)) {</span>
      TarArchiveEntry entry;
<span class="fc bfc" id="L232" title="All 2 branches covered.">      while ((entry = in.getNextTarEntry()) != null) {</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">        if (entry.isDirectory()) {</span>
<span class="fc" id="L234">          LOG.debug(&quot;TAR archive contains directories which are being ignored&quot;);</span>
<span class="fc" id="L235">          continue;</span>
        }
<span class="fc" id="L237">        String fn = new File(entry.getName()).getName();</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">        if (fn.startsWith(&quot;.&quot;)) {</span>
<span class="nc" id="L239">          LOG.debug(&quot;TAR archive contains a hidden file {} which is being ignored&quot;, fn);</span>
<span class="nc" id="L240">          continue;</span>
        }
<span class="fc" id="L242">        File targetFile = new File(directory, fn);</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">        if (targetFile.exists()) {</span>
<span class="nc" id="L244">          LOG.warn(&quot;TAR archive contains duplicate filename {}, only the first was extracted&quot;, fn);</span>
<span class="nc" id="L245">          continue;</span>
        }
<span class="fc" id="L247">        LOG.debug(&quot;Extracting file: {} to: {}&quot;, entry.getName(), targetFile.getAbsolutePath());</span>
<span class="fc" id="L248">        try (FileOutputStream out = new FileOutputStream(targetFile)) {</span>
<span class="fc" id="L249">          IOUtils.copy(in, out);</span>
        }
<span class="fc" id="L251">        files.add(targetFile);</span>
<span class="fc" id="L252">      }</span>
    }
<span class="fc" id="L254">    return files;</span>
  }

  /**
   * Gunzip a file.  Use this method with isTarred false if the gzip contains a single file.  If it's a gzip
   * of a TAR pass true to isTarred (or call @untgzFile(directory, tgzFile) which is what this method
   * just redirects to for isTarred).
   *
   * @param directory the output directory for the uncompressed file(s)
   * @param gzipFile  the gzip file
   * @param isTarred  true if the gzip contains a TAR
   *
   * @return a List of the uncompressed file name(s)
   *
   * @throws IOException if reading or writing fails
   */
  public static List&lt;File&gt; ungzipFile(File directory, File gzipFile, boolean isTarred)
      throws IOException {
<span class="fc bfc" id="L272" title="All 2 branches covered.">    if (isTarred) return untgzFile(directory, gzipFile);</span>

<span class="fc" id="L274">    List&lt;File&gt; files = new ArrayList&lt;File&gt;();</span>
<span class="fc" id="L275">    GZIPInputStream in = null;</span>
<span class="fc" id="L276">    BufferedOutputStream dest = null;</span>
    try {
<span class="fc" id="L278">      in = new GZIPInputStream(new FileInputStream(gzipFile));</span>

      // assume that the gzip filename is the filename + .gz
<span class="fc" id="L281">      String unzippedName = gzipFile.getName().substring(0, gzipFile.getName().lastIndexOf(&quot;.&quot;));</span>
<span class="fc" id="L282">      File outputFile = new File(directory, unzippedName);</span>
<span class="fc" id="L283">      LOG.debug(&quot;Extracting file: {} to: {}&quot;, unzippedName, outputFile.getAbsolutePath());</span>
<span class="fc" id="L284">      FileOutputStream fos = new FileOutputStream(outputFile);</span>

<span class="fc" id="L286">      dest = new BufferedOutputStream(fos, BUFFER);</span>
      int count;
<span class="fc" id="L288">      byte[] data = new byte[BUFFER];</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">      while ((count = in.read(data, 0, BUFFER)) != -1) {</span>
<span class="fc" id="L290">        dest.write(data, 0, count);</span>
      }
<span class="fc" id="L292">      files.add(outputFile);</span>
    } finally {
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">      if (in != null) in.close();</span>
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">      if (dest != null) {</span>
<span class="fc" id="L296">        dest.flush();</span>
<span class="fc" id="L297">        dest.close();</span>
      }
    }

<span class="fc" id="L301">    return files;</span>
  }

  /**
   * Defaults keepSubdirectories to false.
   *
   * @see org.gbif.utils.file.CompressionUtil#unzipFile(java.io.File, java.io.File, boolean)
   */
  public static List&lt;File&gt; unzipFile(File directory, File zipFile) throws IOException {
<span class="fc" id="L310">    return unzipFile(directory, zipFile, false);</span>
  }

  /**
   * Zip a directory with all files but skipping included subdirectories.
   * Only files directly within the directory are added to the archive.
   *
   * @param dir     the directory to zip
   * @param zipFile the zipped file
   */
  public static void zipDir(File dir, File zipFile) throws IOException {
<span class="nc" id="L321">    zipDir(dir, zipFile, false);</span>
<span class="nc" id="L322">  }</span>

  /**
   * Zip a directory with all files. Files in Subdirectories will be included if the inclSubdirs is true.
   *
   * @param dir     the directory to zip
   * @param zipFile the zipped file
   * @param inclSubdirs if true includes all subdirectories recursively
   */
  public static void zipDir(File dir, File zipFile, boolean inclSubdirs) throws IOException {
<span class="fc" id="L332">    Collection&lt;File&gt; files = org.apache.commons.io.FileUtils.listFiles(dir, null, inclSubdirs);</span>
<span class="fc" id="L333">    zipFiles(files, dir, zipFile);</span>
<span class="fc" id="L334">  }</span>

  public static void zipFile(File file, File zipFile) throws IOException {
<span class="nc" id="L337">    Set&lt;File&gt; files = new HashSet&lt;File&gt;();</span>
<span class="nc" id="L338">    files.add(file);</span>
<span class="nc" id="L339">    zipFiles(files, file.getParentFile(), zipFile);</span>
<span class="nc" id="L340">  }</span>

  /**
   * Creates a zip archive from a given collection of files.
   * In order to preserve paths in the archive a rootContext can be specified which will be removed from the individual
   * zip entries. For example a rootContext of /home/freak with a file /home/freak/photo/birthday.jpg to be zipped
   * will result in a zip entry with a path photo/birthday.jpg.
   *
   * @param files to be included in the zip archive
   * @param rootContext optional path to be removed from each file
   * @param zipFile the zip file to be created
   * @throws IOException
   */
  public static void zipFiles(Collection&lt;File&gt; files, File rootContext, File zipFile)
      throws IOException {
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">    if (files.isEmpty()) {</span>
<span class="nc" id="L356">      LOG.info(&quot;no files to zip.&quot;);</span>
    } else {
      try {
<span class="fc" id="L359">        BufferedInputStream origin = null;</span>
<span class="fc" id="L360">        FileOutputStream dest = new FileOutputStream(zipFile);</span>
<span class="fc" id="L361">        ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(dest));</span>
        // out.setMethod(ZipOutputStream.DEFLATED);
<span class="fc" id="L363">        byte[] data = new byte[BUFFER];</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">        for (File f : files) {</span>
<span class="fc" id="L365">          LOG.debug(&quot;Adding file {} to archive&quot;, f);</span>
<span class="fc" id="L366">          FileInputStream fi = new FileInputStream(f);</span>
<span class="fc" id="L367">          origin = new BufferedInputStream(fi, BUFFER);</span>

<span class="fc" id="L369">          String zipPath =</span>
<span class="fc" id="L370">              StringUtils.removeStart(</span>
<span class="fc" id="L371">                  f.getAbsolutePath(), rootContext.getAbsolutePath() + File.separator);</span>
<span class="fc" id="L372">          ZipEntry entry = new ZipEntry(zipPath);</span>
<span class="fc" id="L373">          out.putNextEntry(entry);</span>
          int count;
<span class="fc bfc" id="L375" title="All 2 branches covered.">          while ((count = origin.read(data, 0, BUFFER)) != -1) {</span>
<span class="fc" id="L376">            out.write(data, 0, count);</span>
          }
<span class="fc" id="L378">          origin.close();</span>
<span class="fc" id="L379">        }</span>
<span class="fc" id="L380">        out.finish();</span>
<span class="fc" id="L381">        out.close();</span>
<span class="nc" id="L382">      } catch (IOException e) {</span>
<span class="nc" id="L383">        LOG.error(&quot;IOException while zipping files: {}&quot;, files);</span>
<span class="nc" id="L384">        throw e;</span>
<span class="fc" id="L385">      }</span>
    }
<span class="fc" id="L387">  }</span>

  /**
   * Extracts a zipped file into a target directory. If the file is wrapped in a root directory, this is removed by
   * default. Other subdirectories are ignored according to the parameter keepSubdirectories.
   * &lt;/br&gt;
   * The following types of files are also ignored by default:
   * i) hidden files (i.e. files starting with a dot)
   * ii) Apple resource fork (__MACOSX), including its subdirectories and subfiles
   *
   * @param directory          where the zipped file and its subdirectories should be extracted to
   * @param zipFile            to extract
   * @param keepSubdirectories whether to preserve subdirectories or not
   *
   * @return a list of all created files and directories extracted to target directory
   */
  public static List&lt;File&gt; unzipFile(File directory, File zipFile, boolean keepSubdirectories)
      throws IOException {
<span class="fc" id="L405">    LOG.debug(</span>
        &quot;Unzipping archive &quot;
<span class="fc" id="L407">            + zipFile.getName()</span>
            + &quot; into directory: &quot;
<span class="fc" id="L409">            + directory.getAbsolutePath());</span>

    // This is changed from using ZipFile to a ZipInputStream since Java 8u192 can't open certain
    // Zip64 files.
    // https://bugs.openjdk.java.net/browse/JDK-8186464
<span class="fc" id="L414">    try (FileInputStream fInput = new FileInputStream(zipFile);</span>
<span class="fc" id="L415">        ZipInputStream zipInput = new ZipInputStream(fInput)) {</span>
      ZipEntry entry;

<span class="fc bfc" id="L418" title="All 2 branches covered.">      while ((entry = zipInput.getNextEntry()) != null) {</span>
        // ignore resource fork directories and subfiles
<span class="fc bfc" id="L420" title="All 2 branches covered.">        if (entry.getName().toUpperCase().contains(APPLE_RESOURCE_FORK)) {</span>
<span class="fc" id="L421">          LOG.debug(&quot;Ignoring resource fork file: &quot; + entry.getName());</span>
        }
        // ignore directories and hidden directories (e.g. .svn) (based on flag)
<span class="fc bfc" id="L424" title="All 2 branches covered.">        else if (entry.isDirectory()) {</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">          if (isHiddenFile(new File(entry.getName()))) {</span>
<span class="fc" id="L426">            LOG.debug(&quot;Ignoring hidden directory: &quot; + entry.getName());</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">          } else if (keepSubdirectories) {</span>
<span class="fc" id="L428">            new File(directory, entry.getName()).mkdir();</span>
          } else {
<span class="fc" id="L430">            LOG.debug(&quot;Ignoring (sub)directory: &quot; + entry.getName());</span>
          }
        }
        // ignore hidden files
        else {
<span class="fc bfc" id="L435" title="All 2 branches covered.">          if (isHiddenFile(new File(entry.getName()))) {</span>
<span class="fc" id="L436">            LOG.debug(&quot;Ignoring hidden file: &quot; + entry.getName());</span>
          } else {
            File targetFile =
<span class="fc bfc" id="L439" title="All 2 branches covered.">                (keepSubdirectories)</span>
<span class="fc" id="L440">                    ? new File(directory, entry.getName())</span>
<span class="fc" id="L441">                    : new File(directory, new File(entry.getName()).getName());</span>
            // ensure parent folder always exists, and extract file
<span class="fc" id="L443">            createParentFolder(targetFile);</span>

<span class="fc" id="L445">            LOG.debug(&quot;Extracting file: {} to: {}&quot;, entry.getName(), targetFile.getAbsolutePath());</span>
<span class="fc" id="L446">            try (OutputStream out =</span>
<span class="fc" id="L447">                new BufferedOutputStream(Files.newOutputStream(targetFile.toPath()))) {</span>
<span class="fc" id="L448">              IOUtils.copy(zipInput, out);</span>
            }
<span class="fc" id="L450">          }</span>
        }
      }
    }
    // remove the wrapping root directory and flatten structure
<span class="fc bfc" id="L455" title="All 2 branches covered.">    if (keepSubdirectories) {</span>
<span class="fc" id="L456">      removeRootDirectory(directory);</span>
    }

<span class="fc" id="L459">    File[] files = directory.listFiles();</span>

<span class="pc bpc" id="L461" title="1 of 2 branches missed.">    return (files == null) ? new ArrayList&lt;&gt;() : Arrays.asList(files);</span>
  }

  /**
   * @return true if file is a hidden file or directory, or if any of its parent directories are hidden checking
   * recursively
   */
  private static boolean isHiddenFile(File f) {
<span class="fc bfc" id="L469" title="All 2 branches covered.">    if (f.getName().startsWith(&quot;.&quot;)) {</span>
<span class="fc" id="L470">      return true;</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">    } else if (f.getParentFile() != null) {</span>
<span class="fc" id="L472">      return isHiddenFile(f.getParentFile());</span>
    }
<span class="fc" id="L474">    return false;</span>
  }

  /**
   * Removes a wrapping root directory and flatten its structure by moving all that root directory's files and
   * subdirectories up to the same level as the root directory.
   */
  @SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)
  private static void removeRootDirectory(File directory) {
<span class="fc" id="L483">    File[] rootFiles = directory.listFiles((FileFilter) HiddenFileFilter.VISIBLE);</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">    if (rootFiles == null) {</span>
<span class="nc" id="L485">      LOG.error(&quot;Failed to retrieve root directory from {}&quot;, directory.getAbsolutePath());</span>
<span class="nc" id="L486">      return;</span>
    }

<span class="fc bfc" id="L489" title="All 2 branches covered.">    if (rootFiles.length != 1) {</span>
<span class="fc" id="L490">      LOG.error(&quot;More than one root directory at {}&quot;, directory.getAbsolutePath());</span>
<span class="fc" id="L491">      return;</span>
    }

<span class="fc" id="L494">    File root = rootFiles[0];</span>
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">    if (root.isDirectory()) {</span>
<span class="fc" id="L496">      LOG.debug(</span>
<span class="fc" id="L497">          &quot;Removing single root folder {} found in decompressed archive&quot;, root.getAbsoluteFile());</span>
<span class="fc" id="L498">      Collection&lt;File&gt; filesAndDirs =</span>
<span class="fc" id="L499">          FileUtils.listFilesAndDirs(root, TrueFileFilter.TRUE, TrueFileFilter.TRUE);</span>
      // directories shouldn't be in the end, sort
<span class="fc" id="L501">      List&lt;File&gt; sortedFilesAndDirs =</span>
<span class="fc" id="L502">          filesAndDirs.stream()</span>
<span class="fc" id="L503">              .sorted(Comparator.comparing(File::getAbsolutePath))</span>
<span class="fc" id="L504">              .collect(Collectors.toList());</span>

<span class="fc bfc" id="L506" title="All 2 branches covered.">      for (File f : sortedFilesAndDirs) {</span>
<span class="fc" id="L507">        File f2 = new File(directory, f.getName());</span>
<span class="fc" id="L508">        f.renameTo(f2);</span>
<span class="fc" id="L509">      }</span>
<span class="fc" id="L510">      root.delete();</span>
    }
<span class="fc" id="L512">  }</span>

  /**
   * Make parent folder.
   *
   * @param file destination file
   */
  private static void createParentFolder(File file) {
<span class="fc" id="L520">    File parent = new File(file.getParent());</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">    if (!parent.exists()) {</span>
<span class="fc" id="L522">      LOG.debug(</span>
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">          (parent.mkdirs())</span>
<span class="fc" id="L524">              ? &quot;Created parent directory: &quot; + parent.getAbsolutePath()</span>
<span class="nc" id="L525">              : &quot;Failed to create parent directory: &quot; + parent.getAbsolutePath());</span>
    }
<span class="fc" id="L527">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>