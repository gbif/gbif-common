<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompressionUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GBIF Common</a> &gt; <a href="index.source.html" class="el_package">org.gbif.utils.file</a> &gt; <span class="el_source">CompressionUtil.java</span></div><h1>CompressionUtil.java</h1><pre class="source lang-java linenums">/*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gbif.utils.file;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.zip.GZIPInputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.io.filefilter.HiddenFileFilter;
import org.apache.commons.io.filefilter.TrueFileFilter;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@SuppressWarnings(&quot;unused&quot;)
public class CompressionUtil {

<span class="nc" id="L54">  private CompressionUtil() {</span>
<span class="nc" id="L55">    throw new UnsupportedOperationException(&quot;Can't initialize class&quot;);</span>
  }

  public static class UnsupportedCompressionType extends RuntimeException {

<span class="nc" id="L60">    public UnsupportedCompressionType() {}</span>

    public UnsupportedCompressionType(String message) {
<span class="nc" id="L63">      super(message);</span>
<span class="nc" id="L64">    }</span>

    public UnsupportedCompressionType(String message, Throwable cause) {
<span class="nc" id="L67">      super(message, cause);</span>
<span class="nc" id="L68">    }</span>
  }

<span class="fc" id="L71">  private static final Logger LOG = LoggerFactory.getLogger(CompressionUtil.class);</span>
  private static final int BUFFER = 2048;
  private static final String APPLE_RESOURCE_FORK = &quot;__MACOSX&quot;;
<span class="fc" id="L74">  private static final byte[] TAR_MAGIC_BYTES = new byte[] {'u', 's', 't', 'a', 'r'};</span>

  /**
   * Tries to decompress a file into a newly created temporary directory, trying gzip or zip regardless of the filename
   * or its suffix.
   *
   * @return folder containing all decompressed files
   */
  public static File decompressFile(File compressedFile)
      throws IOException, UnsupportedCompressionType {
    // create empty tmp dir
<span class="nc" id="L85">    File dir = File.createTempFile(&quot;gbif-&quot;, null);</span>
<span class="nc bnc" id="L86" title="All 4 branches missed.">    if (dir.exists() &amp;&amp; !dir.delete()) {</span>
<span class="nc" id="L87">      throw new IOException(&quot;Couldn't delete temporary directory&quot;);</span>
    }

<span class="nc bnc" id="L90" title="All 2 branches missed.">    if (!dir.mkdirs()) {</span>
<span class="nc" id="L91">      throw new IOException(&quot;Couldn't create temporary directory for decompression&quot;);</span>
    }

    // decompress
<span class="nc" id="L95">    decompressFile(dir, compressedFile);</span>

<span class="nc" id="L97">    return dir;</span>
  }

  /**
   * Defaults keeping subDirectories to false.
   *
   * @see org.gbif.utils.file.CompressionUtil#decompressFile(File, File, String, boolean)
   */
  public static List&lt;File&gt; decompressFile(File directory, File compressedFile)
      throws IOException, UnsupportedCompressionType {
<span class="fc" id="L107">    return decompressFile(directory, compressedFile, false);</span>
  }

  /**
   * Defaults keeping subDirectories to false, but provides unzipped file name.
   *
   * @see org.gbif.utils.file.CompressionUtil#decompressFile(File, File, String, boolean)
   */
  public static List&lt;File&gt; decompressFile(
      File directory, File compressedFile, String unzippedFileName)
      throws IOException, UnsupportedCompressionType {
<span class="nc" id="L118">    return decompressFile(directory, compressedFile, unzippedFileName, false);</span>
  }

  /**
   * Defaults keeping subDirectories to false and unzipped file name to null.
   *
   * @see org.gbif.utils.file.CompressionUtil#decompressFile(File, File, String, boolean)
   */
  public static List&lt;File&gt; decompressFile(
      File directory, File compressedFile, boolean keepSubdirectories)
      throws IOException, UnsupportedCompressionType {
<span class="fc" id="L129">    return decompressFile(directory, compressedFile, null, keepSubdirectories);</span>
  }

  /**
   * Tries to decompress a file using TAR+gzip, gzip, TAR or Zip regardless of the filename or its suffix.
   *
   * @param directory      directory where archive's contents will be decompressed to
   * @param compressedFile compressed file
   * @param unzippedFileName unzipped file name (in case of one file)
   *
   * @return list of files that have been extracted or null an empty list if archive couldn't be decompressed
   *
   * @throws IOException                if problem occurred reading compressed file, or directory couldn't be written
   *                                    to
   * @throws UnsupportedCompressionType if the compression type wasn't recognized
   */
  public static List&lt;File&gt; decompressFile(
      File directory, File compressedFile, String unzippedFileName, boolean keepSubdirectories)
      throws IOException, UnsupportedCompressionType {
<span class="fc" id="L148">    List&lt;File&gt; files = null;</span>

    // Test before trying gzip format
<span class="fc bfc" id="L151" title="All 2 branches covered.">    if (isGzipFormat(compressedFile)) {</span>
      try {
<span class="fc" id="L153">        LOG.debug(&quot;Uncompressing {} with gzip compression to {}&quot;, compressedFile, directory);</span>
<span class="fc" id="L154">        files = untgzFile(directory, compressedFile);</span>
<span class="nc" id="L155">      } catch (IOException e) {</span>
<span class="nc" id="L156">        LOG.debug(&quot;Not .tar.gz compression, trying .gz&quot;);</span>
<span class="nc" id="L157">        files = ungzipFile(directory, compressedFile, unzippedFileName, false);</span>
<span class="nc" id="L158">      } catch (Exception e) {</span>
<span class="nc" id="L159">        LOG.error(&quot;Not gzip compression&quot;);</span>
<span class="pc" id="L160">      }</span>
    }

    // Test before trying TAR format
<span class="fc bfc" id="L164" title="All 2 branches covered.">    if (isTarFormat(compressedFile)) {</span>
      try {
<span class="fc" id="L166">        LOG.debug(&quot;Uncompressing {} with TAR compression to {}&quot;, compressedFile, directory);</span>
<span class="fc" id="L167">        files = untarFile(directory, compressedFile);</span>
<span class="nc" id="L168">      } catch (Exception e) {</span>
<span class="nc" id="L169">        LOG.debug(&quot;Not TAR compression&quot;);</span>
<span class="fc" id="L170">      }</span>
    }

    // Then try zip
<span class="fc bfc" id="L174" title="All 2 branches covered.">    if (files == null) {</span>
      try {
<span class="fc" id="L176">        LOG.debug(&quot;Uncompressing {} with Zip compression to {}&quot;, compressedFile, directory);</span>
<span class="fc" id="L177">        files = unzipFile(directory, compressedFile, keepSubdirectories);</span>
<span class="nc" id="L178">      } catch (ZipException e) {</span>
<span class="nc" id="L179">        LOG.debug(&quot;Not Zip compression&quot;);</span>
<span class="nc" id="L180">        throw new UnsupportedCompressionType(&quot;Unknown compression type. Neither gzip nor Zip&quot;, e);</span>
<span class="fc" id="L181">      }</span>
    }

<span class="fc bfc" id="L184" title="All 2 branches covered.">    if (files.isEmpty()) {</span>
<span class="fc" id="L185">      LOG.warn(&quot;No files extracted from {}, tried TGZ, TAR and Zip compression.&quot;, compressedFile);</span>
    }

<span class="fc" id="L188">    return files;</span>
  }

  /**
   * Check the file's first two bytes, to see if they are the gzip magic number.
   * @param compressedFile compressed file
   * @return               true if the file is in gzip format
   * @throws IOException   if a problem occurred reading compressed file
   */
  public static boolean isGzipFormat(File compressedFile) throws IOException {
<span class="fc" id="L198">    try (RandomAccessFile file = new RandomAccessFile(compressedFile, &quot;r&quot;)) {</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">      return GZIPInputStream.GZIP_MAGIC == (file.read() &amp; 0xff | ((file.read() &lt;&lt; 8) &amp; 0xff00));</span>
    }
  }

  /**
   * Check the file is a Tape ARchive (TAR).
   * @param compressedFile compressed file
   * @return               true if the file is a TAR
   * @throws IOException   if a problem occurred reading compressed file
   */
  public static boolean isTarFormat(File compressedFile) throws IOException {
<span class="fc" id="L210">    try (RandomAccessFile file = new RandomAccessFile(compressedFile, &quot;r&quot;)) {</span>
      // TAR files contain &quot;ustar\0&quot; or &quot;ustar &quot; at byte 257.
      // https://www.gnu.org/software/tar/manual/html_node/Standard.html
<span class="fc" id="L213">      byte[] at257 = new byte[5];</span>
<span class="fc" id="L214">      file.seek(257);</span>
<span class="fc" id="L215">      file.read(at257, 0, 5);</span>
<span class="fc" id="L216">      return Arrays.equals(at257, TAR_MAGIC_BYTES);</span>
<span class="nc" id="L217">    } catch (Exception e) {</span>
<span class="nc" id="L218">      LOG.debug(&quot;Exc&quot;, e);</span>
    }
<span class="nc" id="L220">    return false;</span>
  }

  /**
   * Extracts a gzipped TAR file. Directory structure and hidden files (i.e. files starting with a dot) are ignored.
   *
   * @param directory where the file should be extracted to
   * @param tgzFile   to extract
   *
   * @return a list of all created files
   */
  public static List&lt;File&gt; untgzFile(File directory, File tgzFile) throws IOException {
<span class="fc" id="L232">    return untarStream(directory, new GZIPInputStream(Files.newInputStream(tgzFile.toPath())));</span>
  }

  /**
   * Extracts a plain TAR file. Directory structure and hidden files (i.e. files starting with a dot) are ignored.
   *
   * @param directory where the file should be extracted to
   * @param tarFile   to extract
   *
   * @return a list of all created files
   */
  public static List&lt;File&gt; untarFile(File directory, File tarFile) throws IOException {
<span class="fc" id="L244">    return untarStream(directory, Files.newInputStream(tarFile.toPath()));</span>
  }

  /**
   * Extracts a TAR stream. Directory structure and hidden files (i.e. files starting with a dot) are ignored.
   *
   * @param directory where the file should be extracted to
   * @param tarStream to extract
   *
   * @return a list of all created files
   */
  private static List&lt;File&gt; untarStream(File directory, InputStream tarStream) throws IOException {
<span class="fc" id="L256">    List&lt;File&gt; files = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L257">    try (TarArchiveInputStream in = new TarArchiveInputStream(tarStream)) {</span>
      TarArchiveEntry entry;
<span class="fc bfc" id="L259" title="All 2 branches covered.">      while ((entry = in.getNextTarEntry()) != null) {</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">        if (entry.isDirectory()) {</span>
<span class="fc" id="L261">          LOG.debug(&quot;TAR archive contains directories which are being ignored&quot;);</span>
<span class="fc" id="L262">          continue;</span>
        }
<span class="fc" id="L264">        String fn = new File(entry.getName()).getName();</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">        if (fn.startsWith(&quot;.&quot;)) {</span>
<span class="nc" id="L266">          LOG.debug(&quot;TAR archive contains a hidden file {} which is being ignored&quot;, fn);</span>
<span class="nc" id="L267">          continue;</span>
        }
<span class="fc" id="L269">        File targetFile = new File(directory, fn);</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        if (targetFile.exists()) {</span>
<span class="nc" id="L271">          LOG.warn(&quot;TAR archive contains duplicate filename {}, only the first was extracted&quot;, fn);</span>
<span class="nc" id="L272">          continue;</span>
        }
<span class="fc" id="L274">        LOG.debug(&quot;Extracting file: {} to: {}&quot;, entry.getName(), targetFile.getAbsolutePath());</span>
<span class="fc" id="L275">        try (FileOutputStream out = new FileOutputStream(targetFile)) {</span>
<span class="fc" id="L276">          IOUtils.copy(in, out);</span>
        }
<span class="fc" id="L278">        files.add(targetFile);</span>
<span class="fc" id="L279">      }</span>
    }
<span class="fc" id="L281">    return files;</span>
  }

  /**
   * Gunzip a file.  Use this method with isTarred false if the gzip contains a single file.  If it's a gzip
   * of a TAR pass true to isTarred (or call {@link org.gbif.utils.file.CompressionUtil#untgzFile(File, File)}
   * which is what this method just redirects to for isTarred).
   *
   * @param directory the output directory for the uncompressed file(s)
   * @param gzipFile  the gzip file
   * @param isTarred  true if the gzip contains a TAR
   *
   * @return a List of the uncompressed file name(s)
   *
   * @throws IOException if reading or writing fails
   */
  public static List&lt;File&gt; ungzipFile(File directory, File gzipFile, boolean isTarred)
      throws IOException {
<span class="fc bfc" id="L299" title="All 2 branches covered.">    if (isTarred) return untgzFile(directory, gzipFile);</span>

<span class="fc" id="L301">    String unzippedName = gzipFile.getName().substring(0, gzipFile.getName().lastIndexOf(&quot;.&quot;));</span>
<span class="fc" id="L302">    return ungzipFile(directory, gzipFile, unzippedName, isTarred);</span>
  }

  /**
   * Gunzip a file.  Similar to {@link org.gbif.utils.file.CompressionUtil#ungzipFile(File, File, boolean)},
   * but with ability to control unzipped file name.
   *
   * @param directory the output directory for the uncompressed file(s)
   * @param gzipFile  the gzip file
   * @param unzippedName  the unzipped file
   * @param isTarred  true if the gzip contains a TAR
   *
   * @return a List of the uncompressed file name(s)
   *
   * @throws IOException if reading or writing fails
   */
  public static List&lt;File&gt; ungzipFile(
      File directory, File gzipFile, String unzippedName, boolean isTarred) throws IOException {
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">    if (isTarred) return untgzFile(directory, gzipFile);</span>

<span class="fc" id="L322">    List&lt;File&gt; files = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L323">    BufferedOutputStream dest = null;</span>
<span class="fc" id="L324">    try (GZIPInputStream in = new GZIPInputStream(Files.newInputStream(gzipFile.toPath()))) {</span>

      // assume that the gzip filename is the filename + .gz
      String unzippedNameResult;
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">      if (StringUtils.isEmpty(unzippedName)) {</span>
<span class="nc" id="L329">        unzippedNameResult = gzipFile.getName().substring(0, gzipFile.getName().lastIndexOf(&quot;.&quot;));</span>
      } else {
<span class="fc" id="L331">        unzippedNameResult = unzippedName;</span>
      }

<span class="fc" id="L334">      File outputFile = new File(directory, unzippedNameResult);</span>
<span class="fc" id="L335">      LOG.debug(&quot;Extracting file: {} to: {}&quot;, unzippedNameResult, outputFile.getAbsolutePath());</span>
<span class="fc" id="L336">      FileOutputStream fos = new FileOutputStream(outputFile);</span>

<span class="fc" id="L338">      dest = new BufferedOutputStream(fos, BUFFER);</span>
      int count;
<span class="fc" id="L340">      byte[] data = new byte[BUFFER];</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">      while ((count = in.read(data, 0, BUFFER)) != -1) {</span>
<span class="fc" id="L342">        dest.write(data, 0, count);</span>
      }
<span class="fc" id="L344">      files.add(outputFile);</span>
    } finally {
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">      if (dest != null) {</span>
<span class="fc" id="L347">        dest.flush();</span>
<span class="fc" id="L348">        dest.close();</span>
      }
    }

<span class="fc" id="L352">    return files;</span>
  }

  /**
   * Defaults keepSubdirectories to false.
   *
   * @see org.gbif.utils.file.CompressionUtil#unzipFile(java.io.File, java.io.File, boolean)
   */
  public static List&lt;File&gt; unzipFile(File directory, File zipFile) throws IOException {
<span class="fc" id="L361">    return unzipFile(directory, zipFile, false);</span>
  }

  /**
   * Zip a directory with all files but skipping included subdirectories.
   * Only files directly within the directory are added to the archive.
   *
   * @param dir     the directory to zip
   * @param zipFile the zipped file
   */
  public static void zipDir(File dir, File zipFile) throws IOException {
<span class="nc" id="L372">    zipDir(dir, zipFile, false);</span>
<span class="nc" id="L373">  }</span>

  /**
   * Zip a directory with all files. Files in Subdirectories will be included if the inclSubdirs is true.
   *
   * @param dir     the directory to zip
   * @param zipFile the zipped file
   * @param inclSubdirs if true includes all subdirectories recursively
   */
  public static void zipDir(File dir, File zipFile, boolean inclSubdirs) throws IOException {
<span class="fc" id="L383">    Collection&lt;File&gt; files = org.apache.commons.io.FileUtils.listFiles(dir, null, inclSubdirs);</span>
<span class="fc" id="L384">    zipFiles(files, dir, zipFile);</span>
<span class="fc" id="L385">  }</span>

  public static void zipFile(File file, File zipFile) throws IOException {
<span class="nc" id="L388">    Set&lt;File&gt; files = new HashSet&lt;&gt;();</span>
<span class="nc" id="L389">    files.add(file);</span>
<span class="nc" id="L390">    zipFiles(files, file.getParentFile(), zipFile);</span>
<span class="nc" id="L391">  }</span>

  /**
   * Creates a zip archive from a given collection of files.
   * In order to preserve paths in the archive a rootContext can be specified which will be removed from the individual
   * zip entries. For example a rootContext of /home/freak with a file /home/freak/photo/birthday.jpg to be zipped
   * will result in a zip entry with a path photo/birthday.jpg.
   *
   * @param files to be included in the zip archive
   * @param rootContext optional path to be removed from each file
   * @param zipFile the zip file to be created
   * @throws IOException
   */
  public static void zipFiles(Collection&lt;File&gt; files, File rootContext, File zipFile)
      throws IOException {
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">    if (files.isEmpty()) {</span>
<span class="nc" id="L407">      LOG.info(&quot;no files to zip.&quot;);</span>
    } else {
      try {
<span class="fc" id="L410">        BufferedInputStream origin = null;</span>
<span class="fc" id="L411">        FileOutputStream dest = new FileOutputStream(zipFile);</span>
<span class="fc" id="L412">        ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(dest));</span>
        // out.setMethod(ZipOutputStream.DEFLATED);
<span class="fc" id="L414">        byte[] data = new byte[BUFFER];</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">        for (File f : files) {</span>
<span class="fc" id="L416">          LOG.debug(&quot;Adding file {} to archive&quot;, f);</span>
<span class="fc" id="L417">          FileInputStream fi = new FileInputStream(f);</span>
<span class="fc" id="L418">          origin = new BufferedInputStream(fi, BUFFER);</span>

<span class="fc" id="L420">          String zipPath =</span>
<span class="fc" id="L421">              StringUtils.removeStart(</span>
<span class="fc" id="L422">                  f.getAbsolutePath(), rootContext.getAbsolutePath() + File.separator);</span>
<span class="fc" id="L423">          ZipEntry entry = new ZipEntry(zipPath);</span>
<span class="fc" id="L424">          out.putNextEntry(entry);</span>
          int count;
<span class="fc bfc" id="L426" title="All 2 branches covered.">          while ((count = origin.read(data, 0, BUFFER)) != -1) {</span>
<span class="fc" id="L427">            out.write(data, 0, count);</span>
          }
<span class="fc" id="L429">          origin.close();</span>
<span class="fc" id="L430">        }</span>
<span class="fc" id="L431">        out.finish();</span>
<span class="fc" id="L432">        out.close();</span>
<span class="nc" id="L433">      } catch (IOException e) {</span>
<span class="nc" id="L434">        LOG.error(&quot;IOException while zipping files: {}&quot;, files);</span>
<span class="nc" id="L435">        throw e;</span>
<span class="fc" id="L436">      }</span>
    }
<span class="fc" id="L438">  }</span>

  /**
   * Extracts a zipped file into a target directory. If the file is wrapped in a root directory, this is removed by
   * default. Other subdirectories are ignored according to the parameter keepSubdirectories.
   * &lt;/br&gt;
   * The following types of files are also ignored by default:
   * i) hidden files (i.e. files starting with a dot)
   * ii) Apple resource fork (__MACOSX), including its subdirectories and subfiles
   *
   * @param directory          where the zipped file and its subdirectories should be extracted to
   * @param zipFile            to extract
   * @param keepSubdirectories whether to preserve subdirectories or not
   *
   * @return a list of all created files and directories extracted to target directory
   */
  public static List&lt;File&gt; unzipFile(File directory, File zipFile, boolean keepSubdirectories)
      throws IOException {
<span class="fc" id="L456">    LOG.debug(</span>
        &quot;Unzipping archive &quot;
<span class="fc" id="L458">            + zipFile.getName()</span>
            + &quot; into directory: &quot;
<span class="fc" id="L460">            + directory.getAbsolutePath());</span>

    // This is changed from using ZipFile to a ZipInputStream since Java 8u192 can't open certain
    // Zip64 files.
    // https://bugs.openjdk.java.net/browse/JDK-8186464
<span class="fc" id="L465">    try (FileInputStream fInput = new FileInputStream(zipFile);</span>
<span class="fc" id="L466">        ZipInputStream zipInput = new ZipInputStream(fInput)) {</span>
      ZipEntry entry;

<span class="fc bfc" id="L469" title="All 2 branches covered.">      while ((entry = zipInput.getNextEntry()) != null) {</span>
        // ignore resource fork directories and subfiles
<span class="fc bfc" id="L471" title="All 2 branches covered.">        if (entry.getName().toUpperCase().contains(APPLE_RESOURCE_FORK)) {</span>
<span class="fc" id="L472">          LOG.debug(&quot;Ignoring resource fork file: &quot; + entry.getName());</span>
        }
        // ignore directories and hidden directories (e.g. .svn) (based on flag)
<span class="fc bfc" id="L475" title="All 2 branches covered.">        else if (entry.isDirectory()) {</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">          if (isHiddenFile(new File(entry.getName()))) {</span>
<span class="fc" id="L477">            LOG.debug(&quot;Ignoring hidden directory: &quot; + entry.getName());</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">          } else if (keepSubdirectories) {</span>
<span class="fc" id="L479">            new File(directory, entry.getName()).mkdir();</span>
          } else {
<span class="fc" id="L481">            LOG.debug(&quot;Ignoring (sub)directory: &quot; + entry.getName());</span>
          }
        }
        // ignore hidden files
        else {
<span class="fc bfc" id="L486" title="All 2 branches covered.">          if (isHiddenFile(new File(entry.getName()))) {</span>
<span class="fc" id="L487">            LOG.debug(&quot;Ignoring hidden file: &quot; + entry.getName());</span>
          } else {
            File targetFile =
<span class="fc bfc" id="L490" title="All 2 branches covered.">                (keepSubdirectories)</span>
<span class="fc" id="L491">                    ? new File(directory, entry.getName())</span>
<span class="fc" id="L492">                    : new File(directory, new File(entry.getName()).getName());</span>
            // ensure parent folder always exists, and extract file
<span class="fc" id="L494">            createParentFolder(targetFile);</span>

<span class="fc" id="L496">            LOG.debug(&quot;Extracting file: {} to: {}&quot;, entry.getName(), targetFile.getAbsolutePath());</span>
<span class="fc" id="L497">            try (OutputStream out =</span>
<span class="fc" id="L498">                new BufferedOutputStream(Files.newOutputStream(targetFile.toPath()))) {</span>
<span class="fc" id="L499">              IOUtils.copy(zipInput, out);</span>
            }
<span class="fc" id="L501">          }</span>
        }
      }
    }
    // remove the wrapping root directory and flatten structure
<span class="fc bfc" id="L506" title="All 2 branches covered.">    if (keepSubdirectories) {</span>
<span class="fc" id="L507">      removeRootDirectory(directory);</span>
    }

<span class="fc" id="L510">    File[] files = directory.listFiles();</span>

<span class="pc bpc" id="L512" title="1 of 2 branches missed.">    return (files == null) ? new ArrayList&lt;&gt;() : Arrays.asList(files);</span>
  }

  /**
   * @return true if file is a hidden file or directory, or if any of its parent directories are hidden checking
   * recursively
   */
  private static boolean isHiddenFile(File f) {
<span class="fc bfc" id="L520" title="All 2 branches covered.">    if (f.getName().startsWith(&quot;.&quot;)) {</span>
<span class="fc" id="L521">      return true;</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">    } else if (f.getParentFile() != null) {</span>
<span class="fc" id="L523">      return isHiddenFile(f.getParentFile());</span>
    }
<span class="fc" id="L525">    return false;</span>
  }

  /**
   * Removes a wrapping root directory and flatten its structure by moving all that root directory's files and
   * subdirectories up to the same level as the root directory.
   */
  @SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)
  private static void removeRootDirectory(File directory) {
<span class="fc" id="L534">    File[] rootFiles = directory.listFiles((FileFilter) HiddenFileFilter.VISIBLE);</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">    if (rootFiles == null) {</span>
<span class="nc" id="L536">      LOG.error(&quot;Failed to retrieve root directory from {}&quot;, directory.getAbsolutePath());</span>
<span class="nc" id="L537">      return;</span>
    }

<span class="fc bfc" id="L540" title="All 2 branches covered.">    if (rootFiles.length != 1) {</span>
<span class="fc" id="L541">      LOG.error(&quot;More than one root directory at {}&quot;, directory.getAbsolutePath());</span>
<span class="fc" id="L542">      return;</span>
    }

<span class="fc" id="L545">    File root = rootFiles[0];</span>
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">    if (root.isDirectory()) {</span>
<span class="fc" id="L547">      LOG.debug(</span>
<span class="fc" id="L548">          &quot;Removing single root folder {} found in decompressed archive&quot;, root.getAbsoluteFile());</span>
<span class="fc" id="L549">      Collection&lt;File&gt; filesAndDirs =</span>
<span class="fc" id="L550">          FileUtils.listFilesAndDirs(root, TrueFileFilter.TRUE, TrueFileFilter.TRUE);</span>
      // directories shouldn't be in the end, sort
<span class="fc" id="L552">      List&lt;File&gt; sortedFilesAndDirs =</span>
<span class="fc" id="L553">          filesAndDirs.stream()</span>
<span class="fc" id="L554">              .sorted(Comparator.comparing(File::getAbsolutePath))</span>
<span class="fc" id="L555">              .collect(Collectors.toList());</span>

<span class="fc bfc" id="L557" title="All 2 branches covered.">      for (File f : sortedFilesAndDirs) {</span>
<span class="fc" id="L558">        File f2 = new File(directory, f.getName());</span>
<span class="fc" id="L559">        f.renameTo(f2);</span>
<span class="fc" id="L560">      }</span>
<span class="fc" id="L561">      root.delete();</span>
    }
<span class="fc" id="L563">  }</span>

  /**
   * Make parent folder.
   *
   * @param file destination file
   */
  private static void createParentFolder(File file) {
<span class="fc" id="L571">    File parent = new File(file.getParent());</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">    if (!parent.exists()) {</span>
<span class="fc" id="L573">      LOG.debug(</span>
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">          (parent.mkdirs())</span>
<span class="fc" id="L575">              ? &quot;Created parent directory: &quot; + parent.getAbsolutePath()</span>
<span class="nc" id="L576">              : &quot;Failed to create parent directory: &quot; + parent.getAbsolutePath());</span>
    }
<span class="fc" id="L578">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>