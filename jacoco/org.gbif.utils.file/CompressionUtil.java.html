<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompressionUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GBIF Common</a> &gt; <a href="index.source.html" class="el_package">org.gbif.utils.file</a> &gt; <span class="el_source">CompressionUtil.java</span></div><h1>CompressionUtil.java</h1><pre class="source lang-java linenums">/***************************************************************************
 * Copyright 2014 Global Biodiversity Information Facility Secretariat
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ***************************************************************************/

package org.gbif.utils.file;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.zip.GZIPInputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.apache.commons.io.IOUtils;
import org.apache.commons.io.filefilter.HiddenFileFilter;
import org.apache.commons.io.filefilter.TrueFileFilter;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class CompressionUtil {

<span class="nc" id="L51">  private CompressionUtil() {</span>
<span class="nc" id="L52">    throw new UnsupportedOperationException(&quot;Can't initialize class&quot;);</span>
  }

  public static class UnsupportedCompressionType extends RuntimeException {

<span class="nc" id="L57">    public UnsupportedCompressionType() {</span>
<span class="nc" id="L58">    }</span>

    public UnsupportedCompressionType(String message) {
<span class="nc" id="L61">      super(message);</span>
<span class="nc" id="L62">    }</span>

    public UnsupportedCompressionType(String message, Throwable cause) {
<span class="nc" id="L65">      super(message, cause);</span>
<span class="nc" id="L66">    }</span>

  }

<span class="fc" id="L70">  private static final Logger LOG = LoggerFactory.getLogger(CompressionUtil.class);</span>
  private static final int BUFFER = 2048;
  private static final String APPLE_RESOURCE_FORK = &quot;__MACOSX&quot;;

  /**
   * Tries to decompress a file into a newly created temporary directory, trying gzip or zip regardless of the filename
   * or its suffix.
   *
   * @return folder containing all decompressed files
   */
  public static File decompressFile(File compressedFile) throws IOException, UnsupportedCompressionType {
    // create empty tmp dir
<span class="nc" id="L82">    File dir = File.createTempFile(&quot;gbif-&quot;, null);</span>
<span class="nc bnc" id="L83" title="All 4 branches missed.">    if (dir.exists() &amp;&amp; !dir.delete()) {</span>
<span class="nc" id="L84">      throw new IOException(&quot;Couldn't delete temporary directory&quot;);</span>
    }

<span class="nc bnc" id="L87" title="All 2 branches missed.">    if (!dir.mkdirs()) {</span>
<span class="nc" id="L88">      throw new IOException(&quot;Couldn't create temporary directory for decompression&quot;);</span>
    }

    // decompress
<span class="nc" id="L92">    decompressFile(dir, compressedFile);</span>

<span class="nc" id="L94">    return dir;</span>
  }

  /**
   * Defaults keeping subDirectories to false.
   *
   * @see org.gbif.utils.file.CompressionUtil#decompressFile(java.io.File, java.io.File, boolean)
   */
  public static List&lt;File&gt; decompressFile(File directory, File compressedFile)
    throws IOException, UnsupportedCompressionType {
<span class="fc" id="L104">    return decompressFile(directory, compressedFile, false);</span>
  }

  /**
   * Tries to decompress a file trying gzip or zip regardless of the filename or its suffix.
   *
   * @param directory      directory where archive's contents will be decompressed to
   * @param compressedFile compressed file
   *
   * @return list of files that have been extracted or null an empty list if archive couldn't be decompressed
   *
   * @throws IOException                if problem occurred reading compressed file, or directory couldn't be written
   *                                    to
   * @throws UnsupportedCompressionType if the compression type wasn't recognized
   */
  public static List&lt;File&gt; decompressFile(File directory, File compressedFile, boolean keepSubdirectories)
    throws IOException, UnsupportedCompressionType {
<span class="fc" id="L121">    List&lt;File&gt; files = null;</span>

    // Test before trying gzip format
<span class="fc bfc" id="L124" title="All 2 branches covered.">    if (isGzipFormat(compressedFile)) {</span>
      try {
<span class="fc" id="L126">        files = ungzipFile(directory, compressedFile);</span>
<span class="nc" id="L127">      } catch (Exception e) {</span>
<span class="nc" id="L128">        LOG.debug(&quot;No gzip compression&quot;);</span>
<span class="fc" id="L129">      }</span>
    }

    // Then try zip
<span class="fc bfc" id="L133" title="All 2 branches covered.">    if (files == null) {</span>
      try {
<span class="fc" id="L135">        files = unzipFile(directory, compressedFile, keepSubdirectories);</span>
<span class="nc" id="L136">      } catch (ZipException e) {</span>
<span class="nc" id="L137">        LOG.debug(&quot;No zip compression&quot;);</span>
<span class="nc" id="L138">        throw new UnsupportedCompressionType(&quot;Unknown compression type. Neither zip nor gzip&quot;, e);</span>
<span class="fc" id="L139">      }</span>
    }

<span class="fc" id="L142">    return files;</span>
  }

  /**
   * Check the file's first two bytes, to see if they are the gzip magic number.
   * @param compressedFile compressed file
   * @return               true if the file is in gzip format
   * @throws IOException   if a problem occurred reading compressed file
   */
  private static boolean isGzipFormat(File compressedFile) throws IOException {
<span class="fc" id="L152">    try (RandomAccessFile file = new RandomAccessFile(compressedFile, &quot;r&quot;)) {</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">      return GZIPInputStream.GZIP_MAGIC == (file.read() &amp; 0xff | ((file.read() &lt;&lt; 8) &amp; 0xff00));</span>
    }
  }

  /**
   * Extracts a gzipped file. Subdirectories or hidden files (i.e. files starting with a dot) are being ignored.
   *
   * @param directory where the file should be extracted to
   * @param zipFile   to extract
   *
   * @return a list of all created files
   */
  public static List&lt;File&gt; ungzipFile(File directory, File zipFile) throws IOException {
<span class="fc" id="L166">    List&lt;File&gt; files = new ArrayList&lt;File&gt;();</span>
<span class="fc" id="L167">    TarArchiveInputStream in = new TarArchiveInputStream(new GZIPInputStream(new FileInputStream(zipFile)));</span>
    try {
<span class="fc" id="L169">      TarArchiveEntry entry = in.getNextTarEntry();</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">      while (entry != null) {</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (entry.isDirectory()) {</span>
<span class="fc" id="L172">          LOG.debug(&quot;TAR archive contains directories which are being ignored&quot;);</span>
<span class="fc" id="L173">          entry = in.getNextTarEntry();</span>
<span class="fc" id="L174">          continue;</span>
        }
<span class="fc" id="L176">        String fn = new File(entry.getName()).getName();</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        if (fn.startsWith(&quot;.&quot;)) {</span>
<span class="nc" id="L178">          LOG.debug(&quot;TAR archive contains a hidden file which is being ignored&quot;);</span>
<span class="nc" id="L179">          entry = in.getNextTarEntry();</span>
<span class="nc" id="L180">          continue;</span>
        }
<span class="fc" id="L182">        File targetFile = new File(directory, fn);</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">        if (targetFile.exists()) {</span>
<span class="fc" id="L184">          LOG.warn(&quot;TAR archive contains duplicate filenames, only the first is being extracted&quot;);</span>
<span class="fc" id="L185">          entry = in.getNextTarEntry();</span>
<span class="fc" id="L186">          continue;</span>
        }
<span class="fc" id="L188">        LOG.debug(&quot;Extracting file: {} to: {}&quot;, entry.getName(), targetFile.getAbsolutePath());</span>
<span class="fc" id="L189">        FileOutputStream out = new FileOutputStream(targetFile);</span>
        try {
<span class="fc" id="L191">          IOUtils.copy(in, out);</span>
<span class="fc" id="L192">          out.close();</span>
        } finally {
<span class="fc" id="L194">          IOUtils.closeQuietly(out);</span>
        }
<span class="fc" id="L196">        files.add(targetFile);</span>
<span class="fc" id="L197">      }</span>
    } finally {
<span class="fc" id="L199">      in.close();</span>
    }
<span class="fc" id="L201">    return files;</span>
  }

  /**
   * Gunzip a file.  Use this method with isTarred false if the gzip contains a single file.  If it's a gzip
   * of a tar archive pass true to isTarred (or call @ungzipFile(directory, zipFile) which is what this method
   * just redirects to for isTarred).
   *
   * @param directory the output directory for the uncompressed file(s)
   * @param zipFile   the gzip file
   * @param isTarred  true if the gzip contains a tar archive
   *
   * @return a List of the uncompressed file name(s)
   *
   * @throws IOException if reading or writing fails
   */
  public static List&lt;File&gt; ungzipFile(File directory, File zipFile, boolean isTarred) throws IOException {
<span class="fc bfc" id="L218" title="All 2 branches covered.">    if (isTarred) return ungzipFile(directory, zipFile);</span>

<span class="fc" id="L220">    List&lt;File&gt; files = new ArrayList&lt;File&gt;();</span>
<span class="fc" id="L221">    GZIPInputStream in = null;</span>
<span class="fc" id="L222">    BufferedOutputStream dest = null;</span>
    try {
<span class="fc" id="L224">      in = new GZIPInputStream(new FileInputStream(zipFile));</span>

      // assume that the gzip filename is the filename + .gz
<span class="fc" id="L227">      String unzippedName = zipFile.getName().substring(0, zipFile.getName().lastIndexOf(&quot;.&quot;));</span>
<span class="fc" id="L228">      File outputFile = new File(directory, unzippedName);</span>
<span class="fc" id="L229">      LOG.debug(&quot;Extracting file: {} to: {}&quot;, unzippedName, outputFile.getAbsolutePath());</span>
<span class="fc" id="L230">      FileOutputStream fos = new FileOutputStream(outputFile);</span>

<span class="fc" id="L232">      dest = new BufferedOutputStream(fos, BUFFER);</span>
      int count;
<span class="fc" id="L234">      byte[] data = new byte[BUFFER];</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">      while ((count = in.read(data, 0, BUFFER)) != -1) {</span>
<span class="fc" id="L236">        dest.write(data, 0, count);</span>
      }
<span class="fc" id="L238">      files.add(outputFile);</span>
    } finally {
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">      if (in != null) in.close();</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">      if (dest != null) {</span>
<span class="fc" id="L242">        dest.flush();</span>
<span class="fc" id="L243">        dest.close();</span>
      }
    }

<span class="fc" id="L247">    return files;</span>
  }

  /**
   * Defaults keepSubdirectories to false.
   *
   * @see org.gbif.utils.file.CompressionUtil#unzipFile(java.io.File, java.io.File, boolean)
   */
  public static List&lt;File&gt; unzipFile(File directory, File zipFile) throws IOException {
<span class="fc" id="L256">     return unzipFile(directory, zipFile, false);</span>
  }

  /**
   * Zip a directory with all files but skipping included subdirectories.
   * Only files directly within the directory are added to the archive.
   *
   * @param dir     the directory to zip
   * @param zipFile the zipped file
   */
  public static void zipDir(File dir, File zipFile) throws IOException {
<span class="nc" id="L267">    zipDir(dir, zipFile, false);</span>
<span class="nc" id="L268">  }</span>

  /**
   * Zip a directory with all files. Files in Subdirectories will be included if the inclSubdirs is true.
   *
   * @param dir     the directory to zip
   * @param zipFile the zipped file
   * @param inclSubdirs if true includes all subdirectories recursively
   */
  public static void zipDir(File dir, File zipFile, boolean inclSubdirs) throws IOException {
<span class="fc" id="L278">    Collection&lt;File&gt; files = org.apache.commons.io.FileUtils.listFiles(dir, null, inclSubdirs);</span>
<span class="fc" id="L279">    zipFiles(files, dir, zipFile);</span>
<span class="fc" id="L280">  }</span>

  public static void zipFile(File file, File zipFile) throws IOException {
<span class="nc" id="L283">    Set&lt;File&gt; files = new HashSet&lt;File&gt;();</span>
<span class="nc" id="L284">    files.add(file);</span>
<span class="nc" id="L285">    zipFiles(files, file.getParentFile(), zipFile);</span>
<span class="nc" id="L286">  }</span>

  /**
   * Creates a zip archive from a given collection of files.
   * In order to preserve paths in the archive a rootContext can be specified which will be removed from the individual
   * zip entries. For example a rootContext of /home/freak with a file /home/freak/photo/birthday.jpg to be zipped
   * will result in a zip entry with a path photo/birthday.jpg.
   *
   * @param files to be included in the zip archive
   * @param rootContext optional path to be removed from each file
   * @param zipFile the zip file to be created
   * @throws IOException
   */
  public static void zipFiles(Collection&lt;File&gt; files, File rootContext, File zipFile) throws IOException {
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">    if (files.isEmpty()) {</span>
<span class="nc" id="L301">      LOG.info(&quot;no files to zip.&quot;);</span>
    } else {
      try {
<span class="fc" id="L304">        BufferedInputStream origin = null;</span>
<span class="fc" id="L305">        FileOutputStream dest = new FileOutputStream(zipFile);</span>
<span class="fc" id="L306">        ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(dest));</span>
        // out.setMethod(ZipOutputStream.DEFLATED);
<span class="fc" id="L308">        byte[] data = new byte[BUFFER];</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">        for (File f : files) {</span>
<span class="fc" id="L310">          LOG.debug(&quot;Adding file {} to archive&quot;, f);</span>
<span class="fc" id="L311">          FileInputStream fi = new FileInputStream(f);</span>
<span class="fc" id="L312">          origin = new BufferedInputStream(fi, BUFFER);</span>

<span class="fc" id="L314">          String zipPath = StringUtils.removeStart(f.getAbsolutePath(), rootContext.getAbsolutePath() + File.separator);</span>
<span class="fc" id="L315">          ZipEntry entry = new ZipEntry(zipPath);</span>
<span class="fc" id="L316">          out.putNextEntry(entry);</span>
          int count;
<span class="fc bfc" id="L318" title="All 2 branches covered.">          while ((count = origin.read(data, 0, BUFFER)) != -1) {</span>
<span class="fc" id="L319">            out.write(data, 0, count);</span>
          }
<span class="fc" id="L321">          origin.close();</span>
<span class="fc" id="L322">        }</span>
<span class="fc" id="L323">        out.finish();</span>
<span class="fc" id="L324">        out.close();</span>
<span class="nc" id="L325">      } catch (IOException e) {</span>
<span class="nc" id="L326">        LOG.error(&quot;IOException while zipping files: {}&quot;, files);</span>
<span class="nc" id="L327">        throw e;</span>
<span class="fc" id="L328">      }</span>
    }
<span class="fc" id="L330">  }</span>

  /**
   * Extracts a zipped file into a target directory. If the file is wrapped in a root directory, this is removed by
   * default. Other subdirectories are ignored according to the parameter keepSubdirectories.
   * &lt;/br&gt;
   * The following types of files are also ignored by default:
   * i) hidden files (i.e. files starting with a dot)
   * ii) Apple resource fork (__MACOSX), including its subdirectories and subfiles
   *
   * @param directory          where the zipped file and its subdirectories should be extracted to
   * @param zipFile            to extract
   * @param keepSubdirectories whether to preserve subdirectories or not
   *
   * @return a list of all created files and directories extracted to target directory
   */
  public static List&lt;File&gt; unzipFile(File directory, File zipFile, boolean keepSubdirectories) throws IOException {
<span class="fc" id="L347">    LOG.debug(&quot;Unzipping archive &quot; + zipFile.getName() + &quot; into directory: &quot; + directory.getAbsolutePath());</span>

    // This is changed from using ZipFile to a ZipInputStream since Java 8u192 can't open certain Zip64 files.
    // https://bugs.openjdk.java.net/browse/JDK-8186464
<span class="fc" id="L351">    try (FileInputStream fInput = new FileInputStream(zipFile);</span>
<span class="fc" id="L352">         ZipInputStream zipInput = new ZipInputStream(fInput)) {</span>
      ZipEntry entry;

<span class="fc bfc" id="L355" title="All 2 branches covered.">      while ((entry = zipInput.getNextEntry()) != null) {</span>
        // ignore resource fork directories and subfiles
<span class="fc bfc" id="L357" title="All 2 branches covered.">        if (entry.getName().toUpperCase().contains(APPLE_RESOURCE_FORK)) {</span>
<span class="fc" id="L358">          LOG.debug(&quot;Ignoring resource fork file: &quot; + entry.getName());</span>
        }
        // ignore directories and hidden directories (e.g. .svn) (based on flag)
<span class="fc bfc" id="L361" title="All 2 branches covered.">        else if (entry.isDirectory()) {</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">          if (isHiddenFile(new File(entry.getName()))) {</span>
<span class="fc" id="L363">            LOG.debug(&quot;Ignoring hidden directory: &quot; + entry.getName());</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">          } else if (keepSubdirectories) {</span>
<span class="fc" id="L365">            new File(directory, entry.getName()).mkdir();</span>
          } else {
<span class="fc" id="L367">            LOG.debug(&quot;Ignoring (sub)directory: &quot; + entry.getName());</span>
          }
        }
        // ignore hidden files
        else {
<span class="fc bfc" id="L372" title="All 2 branches covered.">          if (isHiddenFile(new File(entry.getName()))) {</span>
<span class="fc" id="L373">            LOG.debug(&quot;Ignoring hidden file: &quot; + entry.getName());</span>
          } else {
<span class="fc bfc" id="L375" title="All 2 branches covered.">            File targetFile = (keepSubdirectories) ? new File(directory, entry.getName())</span>
<span class="fc" id="L376">              : new File(directory, new File(entry.getName()).getName());</span>
            // ensure parent folder always exists, and extract file
<span class="fc" id="L378">            createParentFolder(targetFile);</span>

<span class="fc" id="L380">            LOG.debug(&quot;Extracting file: {} to: {}&quot;, entry.getName(), targetFile.getAbsolutePath());</span>
<span class="fc" id="L381">            try (OutputStream out = new BufferedOutputStream(new FileOutputStream(targetFile))) {</span>
<span class="fc" id="L382">              IOUtils.copy(zipInput, out);</span>
            }
<span class="fc" id="L384">          }</span>
        }
      }
    }
    // remove the wrapping root directory and flatten structure
<span class="fc bfc" id="L389" title="All 2 branches covered.">    if (keepSubdirectories) {</span>
<span class="fc" id="L390">      removeRootDirectory(directory);</span>
    }
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">    return (directory.listFiles() == null) ? new ArrayList&lt;File&gt;() : Arrays.asList(directory.listFiles());</span>
  }

  /**
   * @return true if file is a hidden file or directory, or if any of its parent directories are hidden checking
   * recursively
   */
  private static boolean isHiddenFile(File f) {
<span class="fc bfc" id="L400" title="All 2 branches covered.">    if (f.getName().startsWith(&quot;.&quot;)) {</span>
<span class="fc" id="L401">      return true;</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">    } else if (f.getParentFile() != null) {</span>
<span class="fc" id="L403">      return isHiddenFile(f.getParentFile());</span>
    }
<span class="fc" id="L405">    return false;</span>
  }

  /**
   * Removes a wrapping root directory and flatten its structure by moving all that root directory's files and
   * subdirectories up to the same level as the root directory.
   */
  private static void removeRootDirectory(File directory) {
<span class="fc" id="L413">    File[] rootFiles = directory.listFiles((FileFilter) HiddenFileFilter.VISIBLE);</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">    if (rootFiles.length == 1) {</span>
<span class="fc" id="L415">      File root = rootFiles[0];</span>
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">      if (root.isDirectory()) {</span>
<span class="fc" id="L417">        LOG.debug(&quot;Removing single root folder {} found in decompressed archive&quot;, root.getAbsoluteFile());</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">        for (File f : org.apache.commons.io.FileUtils.listFilesAndDirs(root, TrueFileFilter.TRUE, TrueFileFilter.TRUE)) {</span>
<span class="fc" id="L419">          File f2 = new File(directory, f.getName());</span>
<span class="fc" id="L420">          f.renameTo(f2);</span>
<span class="fc" id="L421">        }</span>
<span class="fc" id="L422">        root.delete();</span>
      }
    }
<span class="fc" id="L425">  }</span>

  /**
   * Make parent folder.
   *
   * @param file destination file
   */
  private static void createParentFolder(File file) {
<span class="fc" id="L433">    File parent = new File(file.getParent());</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">    if (!parent.exists()) {</span>
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">      LOG.debug((parent.mkdirs()) ? &quot;Created parent directory: &quot; + parent.getAbsolutePath()</span>
<span class="nc" id="L436">        : &quot;Failed to create parent directory: &quot; + parent.getAbsolutePath());</span>
    }
<span class="fc" id="L438">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>