<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompressionUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GBIF Common</a> &gt; <a href="index.source.html" class="el_package">org.gbif.utils.file</a> &gt; <span class="el_source">CompressionUtil.java</span></div><h1>CompressionUtil.java</h1><pre class="source lang-java linenums">/*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gbif.utils.file;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.zip.GZIPInputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.apache.commons.io.IOUtils;
import org.apache.commons.io.filefilter.HiddenFileFilter;
import org.apache.commons.io.filefilter.TrueFileFilter;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class CompressionUtil {

<span class="nc" id="L49">  private CompressionUtil() {</span>
<span class="nc" id="L50">    throw new UnsupportedOperationException(&quot;Can't initialize class&quot;);</span>
  }

  public static class UnsupportedCompressionType extends RuntimeException {

<span class="nc" id="L55">    public UnsupportedCompressionType() {}</span>

    public UnsupportedCompressionType(String message) {
<span class="nc" id="L58">      super(message);</span>
<span class="nc" id="L59">    }</span>

    public UnsupportedCompressionType(String message, Throwable cause) {
<span class="nc" id="L62">      super(message, cause);</span>
<span class="nc" id="L63">    }</span>
  }

<span class="fc" id="L66">  private static final Logger LOG = LoggerFactory.getLogger(CompressionUtil.class);</span>
  private static final int BUFFER = 2048;
  private static final String APPLE_RESOURCE_FORK = &quot;__MACOSX&quot;;
<span class="fc" id="L69">  private static final byte[] TAR_MAGIC_BYTES = new byte[] {'u', 's', 't', 'a', 'r'};</span>

  /**
   * Tries to decompress a file into a newly created temporary directory, trying gzip or zip regardless of the filename
   * or its suffix.
   *
   * @return folder containing all decompressed files
   */
  public static File decompressFile(File compressedFile)
      throws IOException, UnsupportedCompressionType {
    // create empty tmp dir
<span class="nc" id="L80">    File dir = File.createTempFile(&quot;gbif-&quot;, null);</span>
<span class="nc bnc" id="L81" title="All 4 branches missed.">    if (dir.exists() &amp;&amp; !dir.delete()) {</span>
<span class="nc" id="L82">      throw new IOException(&quot;Couldn't delete temporary directory&quot;);</span>
    }

<span class="nc bnc" id="L85" title="All 2 branches missed.">    if (!dir.mkdirs()) {</span>
<span class="nc" id="L86">      throw new IOException(&quot;Couldn't create temporary directory for decompression&quot;);</span>
    }

    // decompress
<span class="nc" id="L90">    decompressFile(dir, compressedFile);</span>

<span class="nc" id="L92">    return dir;</span>
  }

  /**
   * Defaults keeping subDirectories to false.
   *
   * @see org.gbif.utils.file.CompressionUtil#decompressFile(java.io.File, java.io.File, boolean)
   */
  public static List&lt;File&gt; decompressFile(File directory, File compressedFile)
      throws IOException, UnsupportedCompressionType {
<span class="fc" id="L102">    return decompressFile(directory, compressedFile, false);</span>
  }

  /**
   * Tries to decompress a file using TAR+gzip, TAR or Zip regardless of the filename or its suffix.
   *
   * @param directory      directory where archive's contents will be decompressed to
   * @param compressedFile compressed file
   *
   * @return list of files that have been extracted or null an empty list if archive couldn't be decompressed
   *
   * @throws IOException                if problem occurred reading compressed file, or directory couldn't be written
   *                                    to
   * @throws UnsupportedCompressionType if the compression type wasn't recognized
   */
  public static List&lt;File&gt; decompressFile(
      File directory, File compressedFile, boolean keepSubdirectories)
      throws IOException, UnsupportedCompressionType {
<span class="fc" id="L120">    List&lt;File&gt; files = null;</span>

    // Test before trying gzip format
<span class="fc bfc" id="L123" title="All 2 branches covered.">    if (isGzipFormat(compressedFile)) {</span>
      try {
<span class="fc" id="L125">        LOG.debug(&quot;Uncompressing {} with gzip compression to {}&quot;, compressedFile, directory);</span>
<span class="fc" id="L126">        files = untgzFile(directory, compressedFile);</span>
<span class="nc" id="L127">      } catch (Exception e) {</span>
<span class="nc" id="L128">        LOG.debug(&quot;Not gzip compression&quot;);</span>
<span class="fc" id="L129">      }</span>
    }

    // Test before trying TAR format
<span class="fc bfc" id="L133" title="All 2 branches covered.">    if (isTarFormat(compressedFile)) {</span>
      try {
<span class="fc" id="L135">        LOG.debug(&quot;Uncompressing {} with TAR compression to {}&quot;, compressedFile, directory);</span>
<span class="fc" id="L136">        files = untarFile(directory, compressedFile);</span>
<span class="nc" id="L137">      } catch (Exception e) {</span>
<span class="nc" id="L138">        LOG.debug(&quot;Not TAR compression&quot;);</span>
<span class="fc" id="L139">      }</span>
    }

    // Then try zip
<span class="fc bfc" id="L143" title="All 2 branches covered.">    if (files == null) {</span>
      try {
<span class="fc" id="L145">        LOG.debug(&quot;Uncompressing {} with Zip compression to {}&quot;, compressedFile, directory);</span>
<span class="fc" id="L146">        files = unzipFile(directory, compressedFile, keepSubdirectories);</span>
<span class="nc" id="L147">      } catch (ZipException e) {</span>
<span class="nc" id="L148">        LOG.debug(&quot;Not Zip compression&quot;);</span>
<span class="nc" id="L149">        throw new UnsupportedCompressionType(&quot;Unknown compression type. Neither gzip nor Zip&quot;, e);</span>
<span class="fc" id="L150">      }</span>
    }

<span class="fc bfc" id="L153" title="All 2 branches covered.">    if (files.isEmpty()) {</span>
<span class="fc" id="L154">      LOG.warn(&quot;No files extracted from {}, tried TGZ, TAR and Zip compression.&quot;, compressedFile);</span>
    }

<span class="fc" id="L157">    return files;</span>
  }

  /**
   * Check the file's first two bytes, to see if they are the gzip magic number.
   * @param compressedFile compressed file
   * @return               true if the file is in gzip format
   * @throws IOException   if a problem occurred reading compressed file
   */
  private static boolean isGzipFormat(File compressedFile) throws IOException {
<span class="fc" id="L167">    try (RandomAccessFile file = new RandomAccessFile(compressedFile, &quot;r&quot;)) {</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">      return GZIPInputStream.GZIP_MAGIC == (file.read() &amp; 0xff | ((file.read() &lt;&lt; 8) &amp; 0xff00));</span>
    }
  }

  /**
   * Check the file is a Tape ARchive (TAR).
   * @param compressedFile compressed file
   * @return               true if the file is a TAR
   * @throws IOException   if a problem occurred reading compressed file
   */
  private static boolean isTarFormat(File compressedFile) throws IOException {
<span class="fc" id="L179">    try (RandomAccessFile file = new RandomAccessFile(compressedFile, &quot;r&quot;)) {</span>
      // TAR files contain &quot;ustar\0&quot; or &quot;ustar &quot; at byte 257.
      // https://www.gnu.org/software/tar/manual/html_node/Standard.html
<span class="fc" id="L182">      byte[] at257 = new byte[5];</span>
<span class="fc" id="L183">      file.seek(257);</span>
<span class="fc" id="L184">      file.read(at257, 0, 5);</span>
<span class="fc" id="L185">      return Arrays.equals(at257, TAR_MAGIC_BYTES);</span>
<span class="nc" id="L186">    } catch (Exception e) {</span>
<span class="nc" id="L187">      LOG.debug(&quot;Exc&quot;, e);</span>
    }
<span class="nc" id="L189">    return false;</span>
  }

  /**
   * Extracts a gzipped TAR file. Directory structure and hidden files (i.e. files starting with a dot) are ignored.
   *
   * @param directory where the file should be extracted to
   * @param tgzFile   to extract
   *
   * @return a list of all created files
   */
  public static List&lt;File&gt; untgzFile(File directory, File tgzFile) throws IOException {
<span class="fc" id="L201">    return untarStream(directory, new GZIPInputStream(new FileInputStream(tgzFile)));</span>
  }

  /**
   * Extracts a plain TAR file. Directory structure and hidden files (i.e. files starting with a dot) are ignored.
   *
   * @param directory where the file should be extracted to
   * @param tarFile   to extract
   *
   * @return a list of all created files
   */
  public static List&lt;File&gt; untarFile(File directory, File tarFile) throws IOException {
<span class="fc" id="L213">    return untarStream(directory, new FileInputStream(tarFile));</span>
  }

  /**
   * Extracts a TAR stream. Directory structure and hidden files (i.e. files starting with a dot) are ignored.
   *
   * @param directory where the file should be extracted to
   * @param tarStream to extract
   *
   * @return a list of all created files
   */
  private static List&lt;File&gt; untarStream(File directory, InputStream tarStream) throws IOException {
<span class="fc" id="L225">    List&lt;File&gt; files = new ArrayList&lt;File&gt;();</span>
<span class="fc" id="L226">    try (TarArchiveInputStream in = new TarArchiveInputStream(tarStream)) {</span>
      TarArchiveEntry entry;
<span class="fc bfc" id="L228" title="All 2 branches covered.">      while ((entry = in.getNextTarEntry()) != null) {</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">        if (entry.isDirectory()) {</span>
<span class="fc" id="L230">          LOG.debug(&quot;TAR archive contains directories which are being ignored&quot;);</span>
<span class="fc" id="L231">          continue;</span>
        }
<span class="fc" id="L233">        String fn = new File(entry.getName()).getName();</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">        if (fn.startsWith(&quot;.&quot;)) {</span>
<span class="nc" id="L235">          LOG.debug(&quot;TAR archive contains a hidden file {} which is being ignored&quot;, fn);</span>
<span class="nc" id="L236">          continue;</span>
        }
<span class="fc" id="L238">        File targetFile = new File(directory, fn);</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">        if (targetFile.exists()) {</span>
<span class="nc" id="L240">          LOG.warn(&quot;TAR archive contains duplicate filename {}, only the first was extracted&quot;, fn);</span>
<span class="nc" id="L241">          continue;</span>
        }
<span class="fc" id="L243">        LOG.debug(&quot;Extracting file: {} to: {}&quot;, entry.getName(), targetFile.getAbsolutePath());</span>
<span class="fc" id="L244">        try (FileOutputStream out = new FileOutputStream(targetFile)) {</span>
<span class="fc" id="L245">          IOUtils.copy(in, out);</span>
        }
<span class="fc" id="L247">        files.add(targetFile);</span>
<span class="fc" id="L248">      }</span>
    }
<span class="fc" id="L250">    return files;</span>
  }

  /**
   * Gunzip a file.  Use this method with isTarred false if the gzip contains a single file.  If it's a gzip
   * of a TAR pass true to isTarred (or call @untgzFile(directory, tgzFile) which is what this method
   * just redirects to for isTarred).
   *
   * @param directory the output directory for the uncompressed file(s)
   * @param gzipFile  the gzip file
   * @param isTarred  true if the gzip contains a TAR
   *
   * @return a List of the uncompressed file name(s)
   *
   * @throws IOException if reading or writing fails
   */
  public static List&lt;File&gt; ungzipFile(File directory, File gzipFile, boolean isTarred)
      throws IOException {
<span class="fc bfc" id="L268" title="All 2 branches covered.">    if (isTarred) return untgzFile(directory, gzipFile);</span>

<span class="fc" id="L270">    List&lt;File&gt; files = new ArrayList&lt;File&gt;();</span>
<span class="fc" id="L271">    GZIPInputStream in = null;</span>
<span class="fc" id="L272">    BufferedOutputStream dest = null;</span>
    try {
<span class="fc" id="L274">      in = new GZIPInputStream(new FileInputStream(gzipFile));</span>

      // assume that the gzip filename is the filename + .gz
<span class="fc" id="L277">      String unzippedName = gzipFile.getName().substring(0, gzipFile.getName().lastIndexOf(&quot;.&quot;));</span>
<span class="fc" id="L278">      File outputFile = new File(directory, unzippedName);</span>
<span class="fc" id="L279">      LOG.debug(&quot;Extracting file: {} to: {}&quot;, unzippedName, outputFile.getAbsolutePath());</span>
<span class="fc" id="L280">      FileOutputStream fos = new FileOutputStream(outputFile);</span>

<span class="fc" id="L282">      dest = new BufferedOutputStream(fos, BUFFER);</span>
      int count;
<span class="fc" id="L284">      byte[] data = new byte[BUFFER];</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">      while ((count = in.read(data, 0, BUFFER)) != -1) {</span>
<span class="fc" id="L286">        dest.write(data, 0, count);</span>
      }
<span class="fc" id="L288">      files.add(outputFile);</span>
    } finally {
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">      if (in != null) in.close();</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">      if (dest != null) {</span>
<span class="fc" id="L292">        dest.flush();</span>
<span class="fc" id="L293">        dest.close();</span>
      }
    }

<span class="fc" id="L297">    return files;</span>
  }

  /**
   * Defaults keepSubdirectories to false.
   *
   * @see org.gbif.utils.file.CompressionUtil#unzipFile(java.io.File, java.io.File, boolean)
   */
  public static List&lt;File&gt; unzipFile(File directory, File zipFile) throws IOException {
<span class="fc" id="L306">    return unzipFile(directory, zipFile, false);</span>
  }

  /**
   * Zip a directory with all files but skipping included subdirectories.
   * Only files directly within the directory are added to the archive.
   *
   * @param dir     the directory to zip
   * @param zipFile the zipped file
   */
  public static void zipDir(File dir, File zipFile) throws IOException {
<span class="nc" id="L317">    zipDir(dir, zipFile, false);</span>
<span class="nc" id="L318">  }</span>

  /**
   * Zip a directory with all files. Files in Subdirectories will be included if the inclSubdirs is true.
   *
   * @param dir     the directory to zip
   * @param zipFile the zipped file
   * @param inclSubdirs if true includes all subdirectories recursively
   */
  public static void zipDir(File dir, File zipFile, boolean inclSubdirs) throws IOException {
<span class="fc" id="L328">    Collection&lt;File&gt; files = org.apache.commons.io.FileUtils.listFiles(dir, null, inclSubdirs);</span>
<span class="fc" id="L329">    zipFiles(files, dir, zipFile);</span>
<span class="fc" id="L330">  }</span>

  public static void zipFile(File file, File zipFile) throws IOException {
<span class="nc" id="L333">    Set&lt;File&gt; files = new HashSet&lt;File&gt;();</span>
<span class="nc" id="L334">    files.add(file);</span>
<span class="nc" id="L335">    zipFiles(files, file.getParentFile(), zipFile);</span>
<span class="nc" id="L336">  }</span>

  /**
   * Creates a zip archive from a given collection of files.
   * In order to preserve paths in the archive a rootContext can be specified which will be removed from the individual
   * zip entries. For example a rootContext of /home/freak with a file /home/freak/photo/birthday.jpg to be zipped
   * will result in a zip entry with a path photo/birthday.jpg.
   *
   * @param files to be included in the zip archive
   * @param rootContext optional path to be removed from each file
   * @param zipFile the zip file to be created
   * @throws IOException
   */
  public static void zipFiles(Collection&lt;File&gt; files, File rootContext, File zipFile)
      throws IOException {
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">    if (files.isEmpty()) {</span>
<span class="nc" id="L352">      LOG.info(&quot;no files to zip.&quot;);</span>
    } else {
      try {
<span class="fc" id="L355">        BufferedInputStream origin = null;</span>
<span class="fc" id="L356">        FileOutputStream dest = new FileOutputStream(zipFile);</span>
<span class="fc" id="L357">        ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(dest));</span>
        // out.setMethod(ZipOutputStream.DEFLATED);
<span class="fc" id="L359">        byte[] data = new byte[BUFFER];</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">        for (File f : files) {</span>
<span class="fc" id="L361">          LOG.debug(&quot;Adding file {} to archive&quot;, f);</span>
<span class="fc" id="L362">          FileInputStream fi = new FileInputStream(f);</span>
<span class="fc" id="L363">          origin = new BufferedInputStream(fi, BUFFER);</span>

<span class="fc" id="L365">          String zipPath =</span>
<span class="fc" id="L366">              StringUtils.removeStart(</span>
<span class="fc" id="L367">                  f.getAbsolutePath(), rootContext.getAbsolutePath() + File.separator);</span>
<span class="fc" id="L368">          ZipEntry entry = new ZipEntry(zipPath);</span>
<span class="fc" id="L369">          out.putNextEntry(entry);</span>
          int count;
<span class="fc bfc" id="L371" title="All 2 branches covered.">          while ((count = origin.read(data, 0, BUFFER)) != -1) {</span>
<span class="fc" id="L372">            out.write(data, 0, count);</span>
          }
<span class="fc" id="L374">          origin.close();</span>
<span class="fc" id="L375">        }</span>
<span class="fc" id="L376">        out.finish();</span>
<span class="fc" id="L377">        out.close();</span>
<span class="nc" id="L378">      } catch (IOException e) {</span>
<span class="nc" id="L379">        LOG.error(&quot;IOException while zipping files: {}&quot;, files);</span>
<span class="nc" id="L380">        throw e;</span>
<span class="fc" id="L381">      }</span>
    }
<span class="fc" id="L383">  }</span>

  /**
   * Extracts a zipped file into a target directory. If the file is wrapped in a root directory, this is removed by
   * default. Other subdirectories are ignored according to the parameter keepSubdirectories.
   * &lt;/br&gt;
   * The following types of files are also ignored by default:
   * i) hidden files (i.e. files starting with a dot)
   * ii) Apple resource fork (__MACOSX), including its subdirectories and subfiles
   *
   * @param directory          where the zipped file and its subdirectories should be extracted to
   * @param zipFile            to extract
   * @param keepSubdirectories whether to preserve subdirectories or not
   *
   * @return a list of all created files and directories extracted to target directory
   */
  public static List&lt;File&gt; unzipFile(File directory, File zipFile, boolean keepSubdirectories)
      throws IOException {
<span class="fc" id="L401">    LOG.debug(</span>
        &quot;Unzipping archive &quot;
<span class="fc" id="L403">            + zipFile.getName()</span>
            + &quot; into directory: &quot;
<span class="fc" id="L405">            + directory.getAbsolutePath());</span>

    // This is changed from using ZipFile to a ZipInputStream since Java 8u192 can't open certain
    // Zip64 files.
    // https://bugs.openjdk.java.net/browse/JDK-8186464
<span class="fc" id="L410">    try (FileInputStream fInput = new FileInputStream(zipFile);</span>
<span class="fc" id="L411">        ZipInputStream zipInput = new ZipInputStream(fInput)) {</span>
      ZipEntry entry;

<span class="fc bfc" id="L414" title="All 2 branches covered.">      while ((entry = zipInput.getNextEntry()) != null) {</span>
        // ignore resource fork directories and subfiles
<span class="fc bfc" id="L416" title="All 2 branches covered.">        if (entry.getName().toUpperCase().contains(APPLE_RESOURCE_FORK)) {</span>
<span class="fc" id="L417">          LOG.debug(&quot;Ignoring resource fork file: &quot; + entry.getName());</span>
        }
        // ignore directories and hidden directories (e.g. .svn) (based on flag)
<span class="fc bfc" id="L420" title="All 2 branches covered.">        else if (entry.isDirectory()) {</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">          if (isHiddenFile(new File(entry.getName()))) {</span>
<span class="fc" id="L422">            LOG.debug(&quot;Ignoring hidden directory: &quot; + entry.getName());</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">          } else if (keepSubdirectories) {</span>
<span class="fc" id="L424">            new File(directory, entry.getName()).mkdir();</span>
          } else {
<span class="fc" id="L426">            LOG.debug(&quot;Ignoring (sub)directory: &quot; + entry.getName());</span>
          }
        }
        // ignore hidden files
        else {
<span class="fc bfc" id="L431" title="All 2 branches covered.">          if (isHiddenFile(new File(entry.getName()))) {</span>
<span class="fc" id="L432">            LOG.debug(&quot;Ignoring hidden file: &quot; + entry.getName());</span>
          } else {
            File targetFile =
<span class="fc bfc" id="L435" title="All 2 branches covered.">                (keepSubdirectories)</span>
<span class="fc" id="L436">                    ? new File(directory, entry.getName())</span>
<span class="fc" id="L437">                    : new File(directory, new File(entry.getName()).getName());</span>
            // ensure parent folder always exists, and extract file
<span class="fc" id="L439">            createParentFolder(targetFile);</span>

<span class="fc" id="L441">            LOG.debug(&quot;Extracting file: {} to: {}&quot;, entry.getName(), targetFile.getAbsolutePath());</span>
<span class="fc" id="L442">            try (OutputStream out = new BufferedOutputStream(new FileOutputStream(targetFile))) {</span>
<span class="fc" id="L443">              IOUtils.copy(zipInput, out);</span>
            }
<span class="fc" id="L445">          }</span>
        }
      }
    }
    // remove the wrapping root directory and flatten structure
<span class="fc bfc" id="L450" title="All 2 branches covered.">    if (keepSubdirectories) {</span>
<span class="fc" id="L451">      removeRootDirectory(directory);</span>
    }
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">    return (directory.listFiles() == null)</span>
<span class="nc" id="L454">        ? new ArrayList&lt;File&gt;()</span>
<span class="fc" id="L455">        : Arrays.asList(directory.listFiles());</span>
  }

  /**
   * @return true if file is a hidden file or directory, or if any of its parent directories are hidden checking
   * recursively
   */
  private static boolean isHiddenFile(File f) {
<span class="fc bfc" id="L463" title="All 2 branches covered.">    if (f.getName().startsWith(&quot;.&quot;)) {</span>
<span class="fc" id="L464">      return true;</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">    } else if (f.getParentFile() != null) {</span>
<span class="fc" id="L466">      return isHiddenFile(f.getParentFile());</span>
    }
<span class="fc" id="L468">    return false;</span>
  }

  /**
   * Removes a wrapping root directory and flatten its structure by moving all that root directory's files and
   * subdirectories up to the same level as the root directory.
   */
  private static void removeRootDirectory(File directory) {
<span class="fc" id="L476">    File[] rootFiles = directory.listFiles((FileFilter) HiddenFileFilter.VISIBLE);</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">    if (rootFiles.length == 1) {</span>
<span class="fc" id="L478">      File root = rootFiles[0];</span>
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">      if (root.isDirectory()) {</span>
<span class="fc" id="L480">        LOG.debug(</span>
<span class="fc" id="L481">            &quot;Removing single root folder {} found in decompressed archive&quot;, root.getAbsoluteFile());</span>
        for (File f :
<span class="fc bfc" id="L483" title="All 2 branches covered.">            org.apache.commons.io.FileUtils.listFilesAndDirs(</span>
                root, TrueFileFilter.TRUE, TrueFileFilter.TRUE)) {
<span class="fc" id="L485">          File f2 = new File(directory, f.getName());</span>
<span class="fc" id="L486">          f.renameTo(f2);</span>
<span class="fc" id="L487">        }</span>
<span class="fc" id="L488">        root.delete();</span>
      }
    }
<span class="fc" id="L491">  }</span>

  /**
   * Make parent folder.
   *
   * @param file destination file
   */
  private static void createParentFolder(File file) {
<span class="fc" id="L499">    File parent = new File(file.getParent());</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">    if (!parent.exists()) {</span>
<span class="fc" id="L501">      LOG.debug(</span>
<span class="pc bpc" id="L502" title="1 of 2 branches missed.">          (parent.mkdirs())</span>
<span class="fc" id="L503">              ? &quot;Created parent directory: &quot; + parent.getAbsolutePath()</span>
<span class="nc" id="L504">              : &quot;Failed to create parent directory: &quot; + parent.getAbsolutePath());</span>
    }
<span class="fc" id="L506">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>