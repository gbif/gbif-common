<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CharsetDetection.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GBIF Common</a> &gt; <a href="index.source.html" class="el_package">org.gbif.utils.file</a> &gt; <span class="el_source">CharsetDetection.java</span></div><h1>CharsetDetection.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2021 Global Biodiversity Information Facility (GBIF)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gbif.utils.file;

import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.StandardCharsets;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static org.gbif.utils.file.FileUtils.readByteBuffer;

/**
 * &lt;p&gt;
 * Utility class to guess the encoding of a given file or byte array. The guess is unfortunately not 100% sure.
 * Especially for 8-bit charsets. It's not possible
 * to know which 8-bit charset is used. Except through statistical analysis.
 * &lt;/p&gt;
 * &lt;p&gt;
 * On the other hand, unicode files encoded in UTF-16 (low or big endian) or UTF-8 files with a Byte Order Marker are
 * easy to find. For UTF-8 files with no BOM,
 * if the buffer is wide enough, it's easy to guess.
 * &lt;/p&gt;
 * &lt;p&gt;
 * To determine whether mostly-English text is UTF-8 or ISO-8859-1, a fairly large buffer may be necessary to find an
 * instance of é, ° etc.
 * &lt;/p&gt;
 * This class is a heavily modified version of the original written by Guillaume LAFORGE:
 * com.glaforge.i18n.io.CharsetToolkit
 * taken from
 * http://glaforge.free.fr/wiki/index.php?wiki=GuessEncoding
 *
 * @author Guillaume LAFORGE
 * @author Markus Döring
 */
public class CharsetDetection {

<span class="fc" id="L57">  private static final Logger LOG = LoggerFactory.getLogger(CharsetDetection.class);</span>
  // encodings to test and very unlikely chars in that encoding
  private static final byte LF = 0x0a;
  private static final byte CR = 0x0d;
  private static final byte TAB = 0x09;

  private static final int UNDEFINED_PENALTY = 100;
  private static final char[] COMMON_NON_ASCII_CHARS;

  static {
<span class="fc" id="L67">    String commonChars = &quot;äåáàæœčéèêëïñøöüßšž°±&quot;;</span>
<span class="fc" id="L68">    CharBuffer cbuf = CharBuffer.allocate(commonChars.length() * 2);</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">    for (char c : commonChars.toCharArray()) {</span>
<span class="fc" id="L70">      cbuf.append(c);</span>
<span class="fc" id="L71">      cbuf.append(Character.toUpperCase(c));</span>
    }
<span class="fc" id="L73">    COMMON_NON_ASCII_CHARS = cbuf.array();</span>
  }

<span class="fc" id="L76">  private static final Charset LATIN1 = StandardCharsets.ISO_8859_1;</span>
  private static final Charset WINDOWS1252;
  private static final Charset MACROMAN;

  static {
<span class="fc" id="L81">    Charset cs = null;</span>
    try {
<span class="fc" id="L83">      cs = Charset.forName(&quot;Cp1252&quot;);</span>
<span class="nc" id="L84">    } catch (Exception e) {</span>
<span class="nc" id="L85">      LOG.warn(&quot;Windows 1252 encoding not supported on this Virtual Machine&quot;);</span>
<span class="fc" id="L86">    }</span>
<span class="fc" id="L87">    WINDOWS1252 = cs;</span>

<span class="fc" id="L89">    cs = null;</span>
    try {
<span class="fc" id="L91">      cs = Charset.forName(&quot;MacRoman&quot;);</span>
<span class="nc" id="L92">    } catch (Exception e) {</span>
<span class="nc" id="L93">      LOG.warn(&quot;MacRoman encoding not supported on this Virtual Machine&quot;);</span>
<span class="fc" id="L94">    }</span>
<span class="fc" id="L95">    MACROMAN = cs;</span>
<span class="fc" id="L96">  }</span>

  private final byte[] buffer;

  /**
   * Constructor of the &lt;code&gt;com.glaforge.i18n.io.CharsetToolkit&lt;/code&gt; utility class.
   *
   * @param buffer the byte buffer of which we want to know the encoding.
   */
<span class="fc" id="L105">  private CharsetDetection(byte[] buffer) {</span>
<span class="fc" id="L106">    this.buffer = buffer;</span>
<span class="fc" id="L107">  }</span>

  public static Charset detectEncoding(File file) throws IOException {
<span class="fc" id="L110">    byte[] data = readByteBuffer(file).array();</span>

<span class="fc" id="L112">    CharsetDetection detector = new CharsetDetection(data);</span>
<span class="fc" id="L113">    Charset charset = detector.detectEncoding();</span>

<span class="fc" id="L115">    LOG.debug(&quot;Detected character encoding &quot; + charset.displayName());</span>
<span class="fc" id="L116">    return charset;</span>
  }

  /**
   * @param bufferLength number of bytes to read in for the detection. Needs to be long enough to encounter non-ASCII
   *                     characters, which could be unusual in English text.
   */
  public static Charset detectEncoding(File file, int bufferLength) throws IOException {
<span class="fc" id="L124">    byte[] data = readByteBuffer(file, bufferLength).array();</span>

<span class="fc" id="L126">    CharsetDetection detector = new CharsetDetection(data);</span>
<span class="fc" id="L127">    Charset charset = detector.detectEncoding();</span>

<span class="fc" id="L129">    LOG.debug(&quot;Detected character encoding &quot; + charset.displayName());</span>
<span class="fc" id="L130">    return charset;</span>
  }

  /**
   * Retrieve the default charset of the system.
   *
   * @return the default &lt;code&gt;Charset&lt;/code&gt;.
   */
  public static Charset getDefaultSystemCharset() {
<span class="nc" id="L139">    return Charset.forName(System.getProperty(&quot;file.encoding&quot;));</span>
  }

  /**
   * Has a Byte Order Marker for UTF-16 Big Endian
   * (utf-16 and ucs-2).
   *
   * @param bom a buffer.
   *
   * @return true if the buffer has a BOM for UTF-16 Big Endian.
   */
  protected static boolean hasUTF16BEBom(byte[] bom) {
<span class="pc bpc" id="L151" title="1 of 4 branches missed.">    return bom[0] == -2 &amp;&amp; bom[1] == -1;</span>
  }

  /**
   * Has a Byte Order Marker for UTF-16 Low Endian
   * (ucs-2le, ucs-4le, and ucs-16le).
   *
   * @param bom a buffer.
   *
   * @return true if the buffer has a BOM for UTF-16 Low Endian.
   */
  protected static boolean hasUTF16LEBom(byte[] bom) {
<span class="pc bpc" id="L163" title="1 of 4 branches missed.">    return bom[0] == -1 &amp;&amp; bom[1] == -2;</span>
  }

  /**
   * Has a Byte Order Marker for UTF-8 (Used by Microsoft's Notepad and other editors).
   *
   * @param bom a buffer.
   *
   * @return true if the buffer has a BOM for UTF8.
   */
  protected static boolean hasUTF8Bom(byte[] bom) {
<span class="pc bpc" id="L174" title="2 of 6 branches missed.">    return bom[0] == -17 &amp;&amp; bom[1] == -69 &amp;&amp; bom[2] == -65;</span>
  }

  private static boolean isCommonChar(char c) {
<span class="fc bfc" id="L178" title="All 2 branches covered.">    for (char cc : COMMON_NON_ASCII_CHARS) {</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">      if (c == cc) {</span>
<span class="fc" id="L180">        return true;</span>
      }
    }
<span class="fc" id="L183">    return false;</span>
  }

  /**
   * If the byte has the form 10xxxxx, then it's a continuation byte of a multiple byte character;
   *
   * @param b a byte.
   *
   * @return true if it's a continuation char.
   */
  private static boolean isContinuationChar(byte b) {
<span class="pc bpc" id="L194" title="1 of 4 branches missed.">    return -128 &lt;= b &amp;&amp; b &lt;= -65;</span>
  }

  /**
   * If the byte has the form 11110xx, then it's the first byte of a five-bytes sequence character.
   *
   * @param b a byte.
   *
   * @return true if it's the first byte of a five-bytes sequence.
   */
  private static boolean isFiveBytesSequence(byte b) {
<span class="pc bpc" id="L205" title="3 of 4 branches missed.">    return -8 &lt;= b &amp;&amp; b &lt;= -5;</span>
  }

  /**
   * If the byte has the form 11110xx, then it's the first byte of a four-bytes sequence character.
   *
   * @param b a byte.
   *
   * @return true if it's the first byte of a four-bytes sequence.
   */
  private static boolean isFourBytesSequence(byte b) {
<span class="pc bpc" id="L216" title="3 of 4 branches missed.">    return -16 &lt;= b &amp;&amp; b &lt;= -9;</span>
  }

  /**
   * If the byte has the form 1110xxx, then it's the first byte of a six-bytes sequence character.
   *
   * @param b a byte.
   *
   * @return true if it's the first byte of a six-bytes sequence.
   */
  private static boolean isSixBytesSequence(byte b) {
<span class="pc bpc" id="L227" title="3 of 4 branches missed.">    return -4 &lt;= b &amp;&amp; b &lt;= -3;</span>
  }

  /**
   * If the byte has the form 1110xxx, then it's the first byte of a three-bytes sequence character.
   *
   * @param b a byte.
   *
   * @return true if it's the first byte of a three-bytes sequence.
   */
  private static boolean isThreeBytesSequence(byte b) {
<span class="pc bpc" id="L238" title="1 of 4 branches missed.">    return -32 &lt;= b &amp;&amp; b &lt;= -17;</span>
  }

  /**
   * If the byte has the form 110xxxx, then it's the first byte of a two-bytes sequence character.
   *
   * @param b a byte.
   *
   * @return true if it's the first byte of a two-bytes sequence.
   */
  private static boolean isTwoBytesSequence(byte b) {
<span class="fc bfc" id="L249" title="All 4 branches covered.">    return -64 &lt;= b &amp;&amp; b &lt;= -33;</span>
  }

  private Charset detectCharacterEncoding8bit() {

    // the number of &quot;bad&quot; chars for the best guess. A better guess will have
<span class="fc" id="L255">    long leastSuspicousChars = testLatin1();</span>
    long suspicousChars;

    // the best guess so far
<span class="fc" id="L259">    Charset bestEncoding = LATIN1;</span>

<span class="pc bpc" id="L261" title="1 of 2 branches missed.">    if (WINDOWS1252 != null) {</span>
<span class="fc" id="L262">      suspicousChars = testWindows1252();</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">      if (suspicousChars &lt; leastSuspicousChars) {</span>
<span class="fc" id="L264">        leastSuspicousChars = suspicousChars;</span>
<span class="fc" id="L265">        bestEncoding = WINDOWS1252;</span>
      }
    }

<span class="pc bpc" id="L269" title="1 of 2 branches missed.">    if (MACROMAN != null) {</span>
<span class="fc" id="L270">      suspicousChars = testMacRoman();</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">      if (suspicousChars &lt; leastSuspicousChars) {</span>
<span class="fc" id="L272">        leastSuspicousChars = suspicousChars;</span>
<span class="fc" id="L273">        bestEncoding = MACROMAN;</span>
      }
    }

<span class="fc" id="L277">    LOG.debug(&quot;8bit Encoding guessed: {} with {} rare characters&quot;, bestEncoding, leastSuspicousChars);</span>
<span class="fc" id="L278">    return bestEncoding;</span>
  }

  /**
   * &lt;p&gt;
   * Guess the encoding of the provided buffer.
   * &lt;/p&gt;
   * If Byte Order Markers are encountered at the beginning of the buffer, we immediately
   * return the charset implied by this BOM. Otherwise, the file would not be a human
   * readable text file.
   * &lt;p/&gt;
   * &lt;p&gt;
   * If there is no BOM, this method tries to discern whether the file is UTF-8 or not. If it is not UTF-8, we assume
   * the encoding is the default system encoding (of course, it might be any 8-bit charset, but usually, an 8-bit
   * charset is the default one).
   * &lt;/p&gt;
   * &lt;p/&gt;
   * &lt;p&gt;
   * It is possible to discern UTF-8 thanks to the pattern of characters with a multi-byte sequence.
   * &lt;/p&gt;
   * &lt;p/&gt;
   * &lt;pre&gt;
   * UCS-4 range (hex.)        UTF-8 octet sequence (binary)
   * 0000 0000-0000 007F       0xxxxxxx
   * 0000 0080-0000 07FF       110xxxxx 10xxxxxx
   * 0000 0800-0000 FFFF       1110xxxx 10xxxxxx 10xxxxxx
   * 0001 0000-001F FFFF       11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
   * 0020 0000-03FF FFFF       111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
   * 0400 0000-7FFF FFFF       1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
   * &lt;/pre&gt;
   * &lt;p&gt;
   * With UTF-8, 0xFE and 0xFF never appear.
   * &lt;/p&gt;
   *
   * @return the Charset recognized or the system default.
   */
  public Charset detectEncoding() {
    // if the file has a Byte Order Marker, we can assume the file is in UTF-xx
    // otherwise, the file would not be human readable
<span class="fc bfc" id="L317" title="All 2 branches covered.">    if (hasUTF8Bom(buffer)) {</span>
<span class="fc" id="L318">      return StandardCharsets.UTF_8;</span>
    }
<span class="fc bfc" id="L320" title="All 2 branches covered.">    if (hasUTF16LEBom(buffer)) {</span>
<span class="fc" id="L321">      return StandardCharsets.UTF_16LE;</span>
    }
<span class="fc bfc" id="L323" title="All 2 branches covered.">    if (hasUTF16BEBom(buffer)) {</span>
<span class="fc" id="L324">      return StandardCharsets.UTF_16BE;</span>
    }

    // if it's not UTF-8 or a BOM present check for UTF16 zeros
<span class="fc" id="L328">    Charset cs = detectUtf16();</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">    if (cs != null) {</span>
<span class="fc" id="L330">      return cs;</span>
    }

    // if the file is in UTF-8, high order bytes must have a certain value, in order to be valid
    // if it's not the case, we can assume the encoding is some 8 bit one
<span class="fc" id="L335">    boolean validU8Char = true;</span>

    // TODO the buffer is not read up to the end, but up to length - 6

<span class="fc" id="L339">    int length = buffer.length;</span>
<span class="fc" id="L340">    int i = 0;</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">    while (i &lt; length - 6) {</span>
<span class="fc" id="L342">      byte b0 = buffer[i];</span>
<span class="fc" id="L343">      byte b1 = buffer[i + 1];</span>
<span class="fc" id="L344">      byte b2 = buffer[i + 2];</span>
<span class="fc" id="L345">      byte b3 = buffer[i + 3];</span>
<span class="fc" id="L346">      byte b4 = buffer[i + 4];</span>
<span class="fc" id="L347">      byte b5 = buffer[i + 5];</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">      if (b0 &lt; 0) {</span>
        // a high order bit was encountered, thus the encoding is not US-ASCII
        // a two-byte sequence was encountered
<span class="fc bfc" id="L351" title="All 2 branches covered.">        if (isTwoBytesSequence(b0)) {</span>
          // there must be one continuation byte of the form 10xxxxxx,
          // otherwise the following character is is not a valid UTF-8 construct
<span class="fc bfc" id="L354" title="All 2 branches covered.">          if (isContinuationChar(b1)) {</span>
<span class="fc" id="L355">            i++;</span>
          } else {
<span class="fc" id="L357">            validU8Char = false;</span>
          }
        }
        // a three-byte sequence was encountered
<span class="fc bfc" id="L361" title="All 2 branches covered.">        else if (isThreeBytesSequence(b0)) {</span>
          // there must be two continuation bytes of the form 10xxxxxx,
          // otherwise the following character is is not a valid UTF-8 construct
<span class="pc bpc" id="L364" title="1 of 4 branches missed.">          if (isContinuationChar(b1) &amp;&amp; isContinuationChar(b2)) {</span>
<span class="fc" id="L365">            i += 2;</span>
          } else {
<span class="fc" id="L367">            validU8Char = false;</span>
          }
        }
        // a four-byte sequence was encountered
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">        else if (isFourBytesSequence(b0)) {</span>
          // there must be three continuation bytes of the form 10xxxxxx,
          // otherwise the following character is is not a valid UTF-8 construct
<span class="nc bnc" id="L374" title="All 6 branches missed.">          if (isContinuationChar(b1) &amp;&amp; isContinuationChar(b2) &amp;&amp; isContinuationChar(b3)) {</span>
<span class="nc" id="L375">            i += 3;</span>
          } else {
<span class="nc" id="L377">            validU8Char = false;</span>
          }
        }
        // a five-byte sequence was encountered
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        else if (isFiveBytesSequence(b0)) {</span>
          // there must be four continuation bytes of the form 10xxxxxx,
          // otherwise the following character is is not a valid UTF-8 construct
<span class="nc bnc" id="L384" title="All 8 branches missed.">          if (isContinuationChar(b1) &amp;&amp; isContinuationChar(b2) &amp;&amp; isContinuationChar(b3) &amp;&amp; isContinuationChar(b4)) {</span>
<span class="nc" id="L385">            i += 4;</span>
          } else {
<span class="nc" id="L387">            validU8Char = false;</span>
          }
        }
        // a six-byte sequence was encountered
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        else if (isSixBytesSequence(b0)) {</span>
          // there must be five continuation bytes of the form 10xxxxxx,
          // otherwise the following character is is not a valid UTF-8 construct
<span class="nc bnc" id="L394" title="All 8 branches missed.">          if (isContinuationChar(b1) &amp;&amp; isContinuationChar(b2) &amp;&amp; isContinuationChar(b3) &amp;&amp; isContinuationChar(b4)</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">              &amp;&amp; isContinuationChar(b5)) {</span>
<span class="nc" id="L396">            i += 5;</span>
          } else {
<span class="nc" id="L398">            validU8Char = false;</span>
          }
        } else {
<span class="fc" id="L401">          validU8Char = false;</span>
        }
      }
<span class="fc bfc" id="L404" title="All 2 branches covered.">      if (!validU8Char) {</span>
<span class="fc" id="L405">        break;</span>
      }
<span class="fc" id="L407">      i++;</span>
<span class="fc" id="L408">    }</span>

    // if no invalid UTF-8 were encountered, we can assume the encoding is UTF-8,
    // otherwise the file would not be human readable
<span class="fc bfc" id="L412" title="All 2 branches covered.">    if (validU8Char) {</span>
<span class="fc" id="L413">      return StandardCharsets.UTF_8;</span>
    }

    // finally it must be some 8bit encoding we try to detect statistically
<span class="fc" id="L417">    return detectCharacterEncoding8bit();</span>
  }

  private Charset detectUtf16() {

    // first try to see if we got a little or big endian, i.e. lots of zeros as the first byte or second byte if we deal
    // with latin characters at least
<span class="fc" id="L424">    int zerosLE = 0;</span>
<span class="fc" id="L425">    int zerosBE = 0;</span>
<span class="fc" id="L426">    boolean even = true;</span>

<span class="fc" id="L428">    int length = buffer.length;</span>
<span class="fc" id="L429">    int i = 0;</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">    while (i &lt; length) {</span>
<span class="fc" id="L431">      byte b = buffer[i];</span>
<span class="fc" id="L432">      i++;</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">      even = !even;</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">      if (b == 0x00) {</span>
        // zero occur a lot in utf16 with latin characters
<span class="fc bfc" id="L436" title="All 2 branches covered.">        if (even) {</span>
<span class="fc" id="L437">          zerosLE++;</span>
        } else {
<span class="fc" id="L439">          zerosBE++;</span>
        }
      }
<span class="fc" id="L442">    }</span>

    // a UTF16 encoding with many latin characters would have either lots of even or uneven bytes as zero - but not both
<span class="fc" id="L445">    int min = buffer.length / 10;</span>
<span class="fc bfc" id="L446" title="All 6 branches covered.">    if ((zerosBE &gt; min || zerosLE &gt; min) &amp;&amp; Math.abs(zerosBE - zerosLE) &gt; min) {</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">      Charset charset = zerosBE &gt; zerosLE ? StandardCharsets.UTF_16BE : StandardCharsets.UTF_16LE;</span>

      // now try to decode the whole lot just to make sure
      try {
<span class="fc" id="L451">        CharsetDecoder decoder = charset.newDecoder();</span>
<span class="fc" id="L452">        decoder.decode(ByteBuffer.wrap(buffer));</span>
        // that worked without a problem - think we got it!
<span class="fc" id="L454">        return charset;</span>
<span class="nc" id="L455">      } catch (CharacterCodingException e) {</span>
        // finally try with the plain UTF16 encoding
<span class="nc" id="L457">        charset = StandardCharsets.UTF_16;</span>
        try {
<span class="nc" id="L459">          CharsetDecoder decoder = charset.newDecoder();</span>
<span class="nc" id="L460">          decoder.decode(ByteBuffer.wrap(buffer));</span>
          // that worked without a problem - think we got it!
<span class="nc" id="L462">          return charset;</span>
<span class="nc" id="L463">        } catch (CharacterCodingException e2) {</span>
        }
      }
    }

<span class="fc" id="L468">    return null;</span>
  }

  private long testLatin1() {
<span class="fc" id="L472">    Charset charset = StandardCharsets.ISO_8859_1;</span>
<span class="fc" id="L473">    CharsetDecoder decoder = charset.newDecoder();</span>

<span class="fc" id="L475">    long suspicious = 0;</span>
    // count the following

    // first try to decode the whole lot and count common non ascii chars
    try {
<span class="fc" id="L480">      CharBuffer cbuf = decoder.decode(ByteBuffer.wrap(buffer));</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">      while (cbuf.hasRemaining()) {</span>
<span class="fc" id="L482">        char c = cbuf.get();</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">        if (isCommonChar(c)) {</span>
<span class="fc" id="L484">          suspicious--;</span>
        }
<span class="fc" id="L486">      }</span>

      // if that worked without a problem try to count suspicious characters which are rarely used in our texts
<span class="fc" id="L489">      int length = buffer.length;</span>
<span class="fc" id="L490">      int i = 0;</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">      while (i &lt; length) {</span>
<span class="fc" id="L492">        byte b = buffer[i];</span>
<span class="fc" id="L493">        i++;</span>
        // range 7f-9f undefined, see http://de.wikipedia.org/wiki/ISO_8859-1
<span class="pc bpc" id="L495" title="1 of 4 branches missed.">        if (b &gt;= (byte) 0x80 &amp;&amp; b &lt;= (byte) 0x9f) {</span>
<span class="fc" id="L496">          suspicious += UNDEFINED_PENALTY;</span>
        }
<span class="fc" id="L498">      }</span>
<span class="nc" id="L499">    } catch (CharacterCodingException e) {</span>
<span class="nc" id="L500">      suspicious = Long.MAX_VALUE;</span>
<span class="fc" id="L501">    }</span>

<span class="fc" id="L503">    return suspicious;</span>
  }

  private long testMacRoman() {
<span class="fc" id="L507">    CharsetDecoder decoder = MACROMAN.newDecoder();</span>

<span class="fc" id="L509">    long suspicious = 0;</span>

    // first try to decode the whole lot
    try {
<span class="fc" id="L513">      CharBuffer cbuf = decoder.decode(ByteBuffer.wrap(buffer));</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">      while (cbuf.hasRemaining()) {</span>
<span class="fc" id="L515">        char c = cbuf.get();</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">        if (isCommonChar(c)) {</span>
<span class="fc" id="L517">          suspicious--;</span>
        }
<span class="fc" id="L519">      }</span>
      // if that worked without a problem try to count suspicious characters which are rarely used in our texts
<span class="fc" id="L521">      int length = buffer.length;</span>
<span class="fc" id="L522">      int i = 0;</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">      while (i &lt; length) {</span>
<span class="fc" id="L524">        byte b = buffer[i];</span>
<span class="fc" id="L525">        i++;</span>
        // all ranges defined I am afraid
<span class="fc" id="L527">      }</span>
<span class="nc" id="L528">    } catch (CharacterCodingException e) {</span>
<span class="nc" id="L529">      suspicious = Long.MAX_VALUE;</span>
<span class="fc" id="L530">    }</span>

<span class="fc" id="L532">    return suspicious;</span>
  }

  private long testWindows1252() {
<span class="fc" id="L536">    CharsetDecoder decoder = WINDOWS1252.newDecoder();</span>
<span class="fc" id="L537">    long suspicious = 0;</span>

    // first try to decode the whole lot
    try {
<span class="fc" id="L541">      CharBuffer cbuf = decoder.decode(ByteBuffer.wrap(buffer));</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">      while (cbuf.hasRemaining()) {</span>
<span class="fc" id="L543">        char c = cbuf.get();</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">        if (isCommonChar(c)) {</span>
<span class="fc" id="L545">          suspicious--;</span>
        }
<span class="fc" id="L547">      }</span>
      // if that worked without a problem try to count suspicous characters which are rarely used in our texts
      // see http://de.wikipedia.org/wiki/ISO_8859-1
<span class="fc" id="L550">      int length = buffer.length;</span>
<span class="fc" id="L551">      int i = 0;</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">      while (i &lt; length) {</span>
<span class="fc" id="L553">        byte b = buffer[i];</span>
<span class="fc" id="L554">        i++;</span>
        // 5 undefined chars
<span class="pc bpc" id="L556" title="5 of 10 branches missed.">        if (b == (byte) 0x81 || b == (byte) 0x8d || b == (byte) 0x8f || b == (byte) 0x90 || b == (byte) 0x9d) {</span>
<span class="nc" id="L557">          suspicious += UNDEFINED_PENALTY;</span>
        }
<span class="fc" id="L559">      }</span>
<span class="nc" id="L560">    } catch (CharacterCodingException e) {</span>
<span class="nc" id="L561">      suspicious = Long.MAX_VALUE;</span>
<span class="fc" id="L562">    }</span>

<span class="fc" id="L564">    return suspicious;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>