<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GBIF Common</a> &gt; <a href="index.source.html" class="el_package">org.gbif.utils.file</a> &gt; <span class="el_source">FileUtils.java</span></div><h1>FileUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gbif.utils.file;

import org.gbif.utils.collection.CompactHashSet;
import org.gbif.utils.text.LineComparator;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.LineIterator;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Collection of file utils.
 * &lt;br&gt;
 * This class has only been tested for use with a UTF-8 system encoding.
 */
<span class="fc" id="L62">public final class FileUtils {</span>

<span class="fc" id="L64">  private static final Logger LOG = LoggerFactory.getLogger(FileUtils.class);</span>

<span class="fc" id="L66">  public static final String UTF8 = StandardCharsets.UTF_8.name();</span>
<span class="fc" id="L67">  public static final Pattern TAB_DELIMITED = Pattern.compile(&quot;\t&quot;);</span>
<span class="fc" id="L68">  private static int linesPerMemorySort = 100000;</span>
<span class="fc" id="L69">  private static Boolean gnuSortAvailable = null;</span>
<span class="fc" id="L70">  private static final Object sortLock = new Object();</span>

  static {
    /* Warn when the software is not run in a Unicode environment.  This library has not been
     * tested to run in a non-Unicode environment, and may cause data corruption.
     */
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">    if (Charset.defaultCharset().equals(StandardCharsets.US_ASCII)) {</span>
<span class="nc" id="L77">      System.err.println(</span>
          &quot;The default character set is US ASCII.  It is strongly recommended to &quot;
              + &quot;run this software in a Unicode environment.&quot;);
    }
<span class="fc" id="L81">  }</span>

  public static String classpath2Filepath(String path) {
<span class="nc" id="L84">    return new File(ClassLoader.getSystemResource(path).getFile()).getAbsolutePath();</span>
  }

  public static InputStream classpathStream(String path) throws IOException {
<span class="fc" id="L88">    InputStream in = null;</span>
    // relative path. Use classpath instead
<span class="fc" id="L90">    URL url = FileUtils.class.getClassLoader().getResource(path);</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">    if (url != null) {</span>
<span class="fc" id="L92">      in = url.openStream();</span>
    }
<span class="fc" id="L94">    return in;</span>
  }

  public static Set&lt;String&gt; columnsToSet(InputStream source, int... column) throws IOException {
<span class="nc" id="L98">    return columnsToSet(source, new CompactHashSet&lt;String&gt;(), column);</span>
  }

  /**
   * Reads a file and returns a unique set of multiple columns from lines which are no comments (starting with #) and
   * trims whitespace.
   *
   * @param source the UTF-8 encoded text file with tab delimited columns
   * @param resultSet the set implementation to be used. Will not be cleared before reading!
   * @param column variable length argument of column indices to process
   * @return set of column rows
   */
  public static Set&lt;String&gt; columnsToSet(InputStream source, Set&lt;String&gt; resultSet, int... column)
      throws IOException {
<span class="nc" id="L112">    LineIterator lines = getLineIterator(source);</span>
<span class="nc" id="L113">    int maxCols = 0;</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">    for (int c : column) {</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">      if (c &gt; maxCols) {</span>
<span class="nc" id="L116">        maxCols = c;</span>
      }
    }
<span class="nc bnc" id="L119" title="All 2 branches missed.">    while (lines.hasNext()) {</span>
<span class="nc" id="L120">      String line = lines.nextLine().trim();</span>
      // ignore comments
<span class="nc bnc" id="L122" title="All 2 branches missed.">      if (!ignore(line)) {</span>
<span class="nc" id="L123">        String[] parts = TAB_DELIMITED.split(line);</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">        if (maxCols &lt;= parts.length) {</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">          for (int c : column) {</span>
<span class="nc" id="L126">            String cell = parts[c].trim();</span>
<span class="nc" id="L127">            resultSet.add(cell);</span>
          }
        }
      }
<span class="nc" id="L131">    }</span>
<span class="nc" id="L132">    return resultSet;</span>
  }

  public static void copyStreams(InputStream in, OutputStream out) throws IOException {
    // write the file to the file specified
    int bytesRead;
<span class="nc" id="L138">    byte[] buffer = new byte[8192];</span>

<span class="nc bnc" id="L140" title="All 2 branches missed.">    while ((bytesRead = in.read(buffer, 0, 8192)) != -1) {</span>
<span class="nc" id="L141">      out.write(buffer, 0, bytesRead);</span>
    }

<span class="nc" id="L144">    out.close();</span>
<span class="nc" id="L145">    in.close();</span>
<span class="nc" id="L146">  }</span>

  public static void copyStreamToFile(InputStream in, File out) throws IOException {
<span class="nc" id="L149">    copyStreams(in, new FileOutputStream(out));</span>
<span class="nc" id="L150">  }</span>

  public static File createTempDir() throws IOException {
<span class="fc" id="L153">    return createTempDir(&quot;gbif-futil&quot;, &quot;.tmp&quot;);</span>
  }

  /**
   * @param prefix The prefix string to be used in generating the file's name; must be at least three characters long
   * @param suffix The suffix string to be used in generating the file's name; may be null, in which case the suffix
   *        &quot;.tmp&quot; will be used
   */
  public static File createTempDir(String prefix, String suffix) throws IOException {
<span class="fc" id="L162">    File dir = File.createTempFile(prefix, suffix);</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">    if (!dir.delete()) {</span>
<span class="nc" id="L164">      throw new IOException(&quot;Could not delete temp file: &quot; + dir.getAbsolutePath());</span>
    }
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">    if (!dir.mkdir()) {</span>
<span class="nc" id="L167">      throw new IOException(&quot;Could not create temp directory: &quot; + dir.getAbsolutePath());</span>
    }
<span class="fc" id="L169">    return dir;</span>
  }

  /**
   * Delete directory recursively, including all its files, sub-folders, and sub-folder's files.
   *
   * @param directory directory to delete recursively
   */
  public static void deleteDirectoryRecursively(File directory) {
<span class="fc" id="L178">    File[] list = directory.listFiles();</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">    for (File file : list) {</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">      if (file.isDirectory()) {</span>
<span class="fc" id="L181">        deleteDirectoryRecursively(file);</span>
<span class="fc" id="L182">        file.delete();</span>
      } else {
<span class="fc" id="L184">        file.delete();</span>
      }
    }
<span class="fc" id="L187">    directory.delete();</span>
<span class="fc" id="L188">  }</span>

  /**
   * Escapes a filename so it is a valid filename on all systems, replacing /. .. \t\r\n.
   *
   * @param filename to be escaped
   */
  public static String escapeFilename(String filename) {
<span class="nc" id="L196">    return filename.replaceAll(&quot;[\\s./&amp;]&quot;, &quot;_&quot;);</span>
  }

  public static File getClasspathFile(String path) {
<span class="fc" id="L200">    return new File(ClassLoader.getSystemResource(path).getFile());</span>
  }

  public static InputStream getInputStream(File source) throws FileNotFoundException {
<span class="fc" id="L204">    return new FileInputStream(source);</span>
  }

  public static BufferedReader getInputStreamReader(InputStream input)
      throws FileNotFoundException {
<span class="nc" id="L209">    return getInputStreamReader(input, UTF8);</span>
  }

  public static BufferedReader getInputStreamReader(InputStream input, String encoding)
      throws FileNotFoundException {
<span class="nc" id="L214">    BufferedReader reader = null;</span>
    try {
<span class="nc" id="L216">      reader = new BufferedReader(new InputStreamReader(input, encoding));</span>
<span class="nc" id="L217">    } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L218">      LOG.warn(&quot;Caught Exception&quot;, e);</span>
<span class="nc" id="L219">    }</span>
<span class="nc" id="L220">    return reader;</span>
  }

  /**
   * @param source the source input stream encoded in UTF-8
   */
  public static LineIterator getLineIterator(InputStream source) {
<span class="nc" id="L227">    return getLineIterator(source, UTF8);</span>
  }

  /**
   * @param source the source input stream
   * @param encoding the encoding used by the input stream
   */
  public static LineIterator getLineIterator(InputStream source, String encoding) {
    try {
<span class="nc" id="L236">      return new LineIterator(new BufferedReader(new InputStreamReader(source, encoding)));</span>
<span class="nc" id="L237">    } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L238">      throw new IllegalArgumentException(&quot;Unsupported encoding&quot; + encoding, e);</span>
    }
  }

  public static BufferedReader getUtf8Reader(File file) throws FileNotFoundException {
<span class="nc" id="L243">    BufferedReader reader = null;</span>
    try {
<span class="nc" id="L245">      reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), UTF8));</span>
<span class="nc" id="L246">    } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L247">      LOG.warn(&quot;Caught Exception&quot;, e);</span>
<span class="nc" id="L248">    }</span>
<span class="nc" id="L249">    return reader;</span>
  }

  /**
   * Converts the byte size into human-readable format.
   * Support both SI and byte format.
   */
  public static String humanReadableByteCount(long bytes, boolean si) {
<span class="fc bfc" id="L257" title="All 2 branches covered.">    int unit = si ? 1000 : 1024;</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">    if (bytes &lt; unit) {</span>
<span class="fc" id="L259">      return bytes + &quot; B&quot;;</span>
    }
<span class="fc" id="L261">    int exp = (int) (Math.log(bytes) / Math.log(unit));</span>
<span class="fc bfc" id="L262" title="All 4 branches covered.">    String pre = (si ? &quot;kMGTPE&quot; : &quot;KMGTPE&quot;).charAt(exp - 1) + (si ? &quot;&quot; : &quot;i&quot;);</span>
<span class="fc" id="L263">    return String.format(&quot;%.1f %sB&quot;, bytes / Math.pow(unit, exp), pre);</span>
  }

  public static boolean isCompressedFile(File source) {
<span class="nc" id="L267">    String suffix = source.getName().substring(source.getName().lastIndexOf('.') + 1);</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">    return suffix != null</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">        &amp;&amp; suffix.length() &gt; 0</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        &amp;&amp; (&quot;zip&quot;.equalsIgnoreCase(suffix)</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">            || &quot;tgz&quot;.equalsIgnoreCase(suffix)</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">            || &quot;gz&quot;.equalsIgnoreCase(suffix));</span>
  }

  /**
   * Reads a complete file into a byte buffer.
   */
  public static ByteBuffer readByteBuffer(File file) throws IOException {
<span class="fc" id="L279">    byte[] content = org.apache.commons.io.FileUtils.readFileToByteArray(file);</span>
<span class="fc" id="L280">    return ByteBuffer.wrap(content);</span>
  }

  /**
   * Reads the first bytes of a file into a byte buffer.
   *
   * @param bufferSize the number of bytes to read from the file
   */
  public static ByteBuffer readByteBuffer(File file, int bufferSize) throws IOException {
<span class="fc" id="L289">    ByteBuffer bbuf = ByteBuffer.allocate(bufferSize);</span>
<span class="fc" id="L290">    BufferedInputStream f = new BufferedInputStream(new FileInputStream(file), bufferSize);</span>

    int b;
<span class="fc bfc" id="L293" title="All 2 branches covered.">    while ((b = f.read()) != -1) {</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">      if (!bbuf.hasRemaining()) {</span>
<span class="fc" id="L295">        break;</span>
      }
<span class="fc" id="L297">      bbuf.put((byte) b);</span>
    }
<span class="fc" id="L299">    f.close();</span>

<span class="fc" id="L301">    return bbuf;</span>
  }

  /**
   * @param linesPerMemorySort are the number of lines that should be sorted in memory, determining the number of file
   *        segments to be sorted when doing a Java file sort. Defaults to 100000, if you have
   *        memory available a higher value increases performance.
   */
  public static void setLinesPerMemorySort(int linesPerMemorySort) {
<span class="nc" id="L310">    FileUtils.linesPerMemorySort = linesPerMemorySort;</span>
<span class="nc" id="L311">  }</span>

  public static Writer startNewUtf8File(File file) throws IOException {
<span class="nc" id="L314">    touch(file);</span>
<span class="nc" id="L315">    return new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file, false), UTF8));</span>
  }

  public static Writer startNewUtf8XmlFile(File file) throws IOException {
<span class="nc" id="L319">    Writer writer = startNewUtf8File(file);</span>
<span class="nc" id="L320">    writer.write(&quot;&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&quot;);</span>
<span class="nc" id="L321">    return writer;</span>
  }

  /**
   * Takes a utf8 encoded input stream and reads in every line/row into a list.
   *
   * @return list of rows
   */
  public static LinkedList&lt;String&gt; streamToList(InputStream source) throws IOException {
<span class="fc" id="L330">    return streamToList(source, FileUtils.UTF8);</span>
  }

  /**
   * Reads a file and returns a list of all lines which are no comments (starting with #) and trims whitespace.
   *
   * @param source the UTF-8 encoded text file to read
   * @param resultList the list implementation to be used. Will not be cleared before reading!
   * @return list of lines
   */
  public static List&lt;String&gt; streamToList(InputStream source, List&lt;String&gt; resultList)
      throws IOException {
<span class="nc" id="L342">    LineIterator lines = getLineIterator(source);</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">    while (lines.hasNext()) {</span>
<span class="nc" id="L344">      String line = lines.nextLine().trim();</span>
      // ignore comments
<span class="nc bnc" id="L346" title="All 2 branches missed.">      if (!ignore(line)) {</span>
<span class="nc" id="L347">        resultList.add(line);</span>
      }
<span class="nc" id="L349">    }</span>
<span class="nc" id="L350">    return resultList;</span>
  }

  public static LinkedList&lt;String&gt; streamToList(InputStream source, String encoding)
      throws IOException {
<span class="fc" id="L355">    LinkedList&lt;String&gt; resultList = new LinkedList&lt;&gt;();</span>
    try {
<span class="fc" id="L357">      LineIterator lines =</span>
          new LineIterator(new BufferedReader(new InputStreamReader(source, encoding)));
<span class="fc bfc" id="L359" title="All 2 branches covered.">      while (lines.hasNext()) {</span>
<span class="fc" id="L360">        String line = lines.nextLine();</span>
<span class="fc" id="L361">        resultList.add(line);</span>
<span class="fc" id="L362">      }</span>
<span class="nc" id="L363">    } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L364">      throw new IllegalArgumentException(&quot;Unsupported encoding &quot; + encoding, e);</span>
<span class="fc" id="L365">    }</span>
<span class="fc" id="L366">    return resultList;</span>
  }

  /**
   * Reads a utf8 encoded inut stream, splits
   */
  public static Map&lt;String, String&gt; streamToMap(InputStream source) throws IOException {
<span class="nc" id="L373">    return streamToMap(source, new HashMap&lt;&gt;());</span>
  }

  public static Map&lt;String, String&gt; streamToMap(
      InputStream source, int key, int value, boolean trimToNull) throws IOException {
<span class="nc" id="L378">    return streamToMap(source, new HashMap&lt;&gt;(), key, value, trimToNull);</span>
  }

  /**
   * Read a hashmap from a tab delimited utf8 input stream using the row number as an integer value and the entire row
   * as the value. Ignores commented rows starting with #.
   *
   * @param source tab delimited text file to read
   */
  public static Map&lt;String, String&gt; streamToMap(InputStream source, Map&lt;String, String&gt; result)
      throws IOException {
<span class="nc" id="L389">    LineIterator lines = getLineIterator(source);</span>
<span class="nc" id="L390">    Integer row = 0;</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">    while (lines.hasNext()) {</span>
<span class="nc" id="L392">      row++;</span>
<span class="nc" id="L393">      String line = lines.nextLine().trim();</span>
      // ignore comments
<span class="nc bnc" id="L395" title="All 2 branches missed.">      if (!ignore(line)) {</span>
<span class="nc" id="L396">        result.put(line, row.toString());</span>
      }
<span class="nc" id="L398">    }</span>
<span class="nc" id="L399">    return result;</span>
  }

  /**
   * Read a hashmap from a tab delimited utf8 file, ignoring commented rows starting with #.
   *
   * @param source tab delimited input stream to read
   * @param key column number to use as key
   * @param value column number to use as value
   * @param trimToNull if true trims map entries to null
   */
  public static Map&lt;String, String&gt; streamToMap(
      InputStream source, Map&lt;String, String&gt; result, int key, int value, boolean trimToNull)
      throws IOException {
<span class="nc" id="L413">    LineIterator lines = getLineIterator(source);</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">    int maxCols = key &gt; value ? key : value + 1;</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">    while (lines.hasNext()) {</span>
<span class="nc" id="L416">      String line = lines.nextLine();</span>
      // ignore comments
<span class="nc bnc" id="L418" title="All 2 branches missed.">      if (!ignore(line)) {</span>
<span class="nc" id="L419">        String[] parts = TAB_DELIMITED.split(line);</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">        if (maxCols &lt;= parts.length) {</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">          if (trimToNull) {</span>
<span class="nc" id="L422">            result.put(StringUtils.trimToNull(parts[key]), StringUtils.trimToNull(parts[value]));</span>
          } else {
<span class="nc" id="L424">            result.put(parts[key], parts[value]);</span>
          }
        }
      }
<span class="nc" id="L428">    }</span>
<span class="nc" id="L429">    return result;</span>
  }

  public static Set&lt;String&gt; streamToSet(InputStream source) throws IOException {
<span class="nc" id="L433">    return streamToSet(source, new CompactHashSet&lt;&gt;());</span>
  }

  /**
   * Reads a file and returns a unique set of all lines which are no comments (starting with #) and trims whitespace.
   *
   * @param source the UTF-8 encoded text file to read
   * @param resultSet the set implementation to be used. Will not be cleared before reading!
   * @return set of unique lines
   */
  public static Set&lt;String&gt; streamToSet(InputStream source, Set&lt;String&gt; resultSet)
      throws IOException {
<span class="nc" id="L445">    LineIterator lines = getLineIterator(source);</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">    while (lines.hasNext()) {</span>
<span class="nc" id="L447">      String line = lines.nextLine().trim();</span>
      // ignore comments
<span class="nc bnc" id="L449" title="All 2 branches missed.">      if (!ignore(line)) {</span>
<span class="nc" id="L450">        resultSet.add(line);</span>
      }
<span class="nc" id="L452">    }</span>
<span class="nc" id="L453">    return resultSet;</span>
  }

  public static String toFilePath(URL url) {
    String protocol =
<span class="pc bpc" id="L458" title="1 of 4 branches missed.">        url.getProtocol() == null || &quot;http&quot;.equalsIgnoreCase(url.getProtocol())</span>
<span class="fc" id="L459">            ? &quot;&quot;</span>
<span class="fc" id="L460">            : &quot;/__&quot; + url.getProtocol() + &quot;__&quot;;</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">    String domain = url.getAuthority() == null ? &quot;__domainless&quot; : url.getAuthority();</span>
<span class="fc" id="L462">    return domain + protocol + url.getFile();</span>
  }

  public static File url2file(URL url) {
<span class="nc" id="L466">    File f = null;</span>
    try {
<span class="nc" id="L468">      f = new File(url.toURI());</span>
<span class="nc" id="L469">    } catch (URISyntaxException e) {</span>
<span class="nc" id="L470">      f = new File(url.getPath());</span>
<span class="nc" id="L471">    }</span>
<span class="nc" id="L472">    return f;</span>
  }

  /**
   * For the given list, finds the index of the lowest value using the given comparator.
   *
   * @param values To compare
   * @param comparator To use
   * @return The index of the lowest value, or -1 if they are all null
   */
  static int lowestValueIndex(List&lt;String&gt; values, Comparator&lt;String&gt; comparator) {
<span class="nc" id="L483">    int index = 0;</span>
<span class="nc" id="L484">    String lowestValue = null;</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">    for (int i = 0; i &lt; values.size(); i++) {</span>
<span class="nc" id="L486">      String value = values.get(i);</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">      if (lowestValue == null) {</span>
<span class="nc" id="L488">        lowestValue = value;</span>
<span class="nc" id="L489">        index = i;</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">      } else if (comparator.compare(lowestValue, value) &gt; 0) {</span>
<span class="nc" id="L491">        lowestValue = value;</span>
<span class="nc" id="L492">        index = i;</span>
      }
    }

<span class="nc bnc" id="L496" title="All 2 branches missed.">    return lowestValue == null ? -1 : index;</span>
  }

  /**
   * For the given file's path, returns a proposed new filename (including path) with the extension
   * index and suffix. So a file of &quot;/tmp/input.txt&quot; -&gt; &quot;/tmp/input_part_10.txt&quot;.
   *
   * @param original File
   * @param index E.g. 10
   * @return The proposed name
   */
  private static File getChunkFile(File original, int index) {
<span class="fc" id="L508">    return new File(</span>
<span class="fc" id="L509">        original.getParentFile(),</span>
<span class="fc" id="L510">        FilenameUtils.getBaseName(original.getName())</span>
            + '_'
            + index
<span class="fc" id="L513">            + getFileExtension(original.getName()));</span>
  }

  private static boolean ignore(String line) {
<span class="nc bnc" id="L517" title="All 4 branches missed.">    return StringUtils.trimToNull(line) == null || line.startsWith(&quot;#&quot;);</span>
  }

  public int getLinesPerMemorySort() {
<span class="nc" id="L521">    return linesPerMemorySort;</span>
  }

  /**
   * Merges a list of intermediary sort chunk files into a single sorted file. On completion, the intermediary sort
   * chunk files are deleted.
   *
   * @param sortFiles sort chunk files to merge
   * @param sortedFileWriter writer to merge to. Can already be open and contain data
   * @param lineComparator To use when determining the order (reuse the one that was used to sort the individual
   *        files)
   */
  public void mergeSortedFiles(
      List&lt;File&gt; sortFiles, Writer sortedFileWriter, Comparator&lt;String&gt; lineComparator)
      throws IOException {
<span class="fc" id="L536">    LinkedList&lt;Pair&lt;String, BufferedReader&gt;&gt; partReaders = new LinkedList&lt;&gt;();</span>
    try {
<span class="fc bfc" id="L538" title="All 2 branches covered.">      for (File f : sortFiles) {</span>
        // Use UTF-8 sort order.
<span class="fc" id="L540">        BufferedReader partReader =</span>
            new BufferedReader(
                new InputStreamReader(new FileInputStream(f), StandardCharsets.UTF_8));
        // Load first lines
<span class="fc" id="L544">        String partLine = partReader.readLine();</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">        if (partLine != null) {</span>
<span class="fc" id="L546">          partReaders.add(Pair.of(partLine, partReader));</span>
        }
<span class="fc" id="L548">      }</span>
      // Sort the first lines
<span class="fc" id="L550">      Collections.sort(partReaders, (Comparator.comparing(Pair::getLeft, lineComparator)));</span>

      // Start with the first reader
<span class="fc bfc" id="L553" title="All 2 branches covered.">      while (partReaders.size() &gt; 1) {</span>
<span class="fc" id="L554">        BufferedReader currentBuffer = partReaders.get(0).getRight();</span>
<span class="fc" id="L555">        String currentLine = partReaders.get(0).getLeft();</span>
<span class="fc" id="L556">        String nextFilesFirstLine = partReaders.get(1).getLeft();</span>

        // Read from it, until its value is greater than the second reader.
<span class="fc bfc" id="L559" title="All 2 branches covered.">        while (currentLine != null</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">            &amp;&amp; lineComparator.compare(currentLine, nextFilesFirstLine) &lt;= 0) {</span>
<span class="fc" id="L561">          sortedFileWriter.write(currentLine);</span>
<span class="fc" id="L562">          sortedFileWriter.write('\n');</span>

<span class="fc" id="L564">          currentLine = currentBuffer.readLine();</span>
        }
<span class="fc" id="L566">        partReaders.remove(0);</span>

<span class="fc bfc" id="L568" title="All 2 branches covered.">        if (currentLine == null) {</span>
          // If it's completed, close and remove it.
<span class="fc" id="L570">          currentBuffer.close();</span>
        } else {
          // Otherwise, insert it into the list, maintaining the order
<span class="fc" id="L573">          Pair&lt;String, BufferedReader&gt; currentReaderPair = Pair.of(currentLine, currentBuffer);</span>

          // Start at 1, as we are always larger than the first (was the second) entry
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">          for (int i = 1; i &lt; partReaders.size(); i++) {</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">            if (lineComparator.compare(partReaders.get(i).getLeft(), currentLine) &gt;= 0) {</span>
<span class="fc" id="L578">              partReaders.add(i, currentReaderPair);</span>
<span class="fc" id="L579">              break;</span>
            }

            // If we get here, it goes at the end of the list.
<span class="fc bfc" id="L583" title="All 2 branches covered.">            if (i + 1 == partReaders.size()) {</span>
<span class="fc" id="L584">              partReaders.add(i + 1, currentReaderPair);</span>
<span class="fc" id="L585">              break;</span>
            }
          }
        }
<span class="fc" id="L589">      }</span>

      // Read the remainder of the final buffer
<span class="fc" id="L592">      BufferedReader currentBuffer = partReaders.get(0).getRight();</span>
<span class="fc" id="L593">      String current = partReaders.get(0).getLeft();</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">      while (current != null) {</span>
<span class="fc" id="L595">        sortedFileWriter.write(current);</span>
<span class="fc" id="L596">        sortedFileWriter.write('\n');</span>

<span class="fc" id="L598">        current = currentBuffer.readLine();</span>
      }
<span class="fc" id="L600">      currentBuffer.close();</span>

    } finally {
<span class="fc bfc" id="L603" title="All 2 branches covered.">      for (Pair&lt;String, BufferedReader&gt; pair : partReaders) {</span>
        try {
<span class="fc" id="L605">          pair.getRight().close();</span>
<span class="nc" id="L606">        } catch (RuntimeException e) {</span>
<span class="fc" id="L607">        }</span>
<span class="fc" id="L608">      }</span>
      // I assume it periodically flushes anyway, so only need to do once at end...
<span class="fc" id="L610">      sortedFileWriter.flush();</span>
<span class="fc" id="L611">      sortedFileWriter.close();</span>
      // delete (intermediary) sort chunk files, only the sorted file remains
<span class="fc bfc" id="L613" title="All 2 branches covered.">      for (File f : sortFiles) {</span>
<span class="fc" id="L614">        f.delete();</span>
<span class="fc" id="L615">      }</span>
    }
<span class="fc" id="L617">  }</span>

  /**
   * Sorts the input file into the output file using the supplied delimited line parameters.
   *
   * This method is not reliable when the sort field may contain Unicode codepoints outside the Basic Multilingual Plane,
   * i.e. above \uFFFF. In that case, the sort order differs from Java's String sort order.  This should not be a problem
   * for most usage; the Supplementary Multilingual Planes contain ancient scripts, emojis, arrows and so on.
   *
   * @param input To sort
   * @param sorted The sorted version of the input excluding ignored header lines (see ignoreHeaderLines)
   * @param column the column that keeps the values to sort on
   * @param columnDelimiter the delimiter that separates columns in a row
   * @param enclosedBy optional column enclosing character, e.g. a double quote for CSVs
   * @param newlineDelimiter the chars used for new lines, usually \n, \n\r or \r
   * @param ignoreHeaderLines number of beginning lines to ignore, e.g. headers
   */
  public void sort(
      File input,
      File sorted,
      String encoding,
      int column,
      String columnDelimiter,
      Character enclosedBy,
      String newlineDelimiter,
      int ignoreHeaderLines)
      throws IOException {
<span class="fc" id="L644">    sort(</span>
<span class="fc" id="L645">        Collections.singletonList(input),</span>
        sorted,
        encoding,
        column,
        columnDelimiter,
        enclosedBy,
        newlineDelimiter,
        ignoreHeaderLines);
<span class="fc" id="L653">  }</span>

  /**
   * Sorts the input file into the output file using the supplied delimited line parameters.
   *
   * This method is not reliable when the sort field may contain Unicode codepoints outside the Basic Multilingual Plane,
   * i.e. above \uFFFF. In that case, the sort order differs from Java's String sort order.  This should not be a problem
   * for most usage; the Supplementary Multilingual Planes contain ancient scripts, emojis, arrows and so on.
   *
   * @param inputs To sort
   * @param sorted The sorted version of the input excluding ignored header lines (see ignoreHeaderLines)
   * @param column the column that keeps the values to sort on
   * @param columnDelimiter the delimiter that separates columns in a row
   * @param enclosedBy optional column enclosing character, e.g. a double quote for CSVs
   * @param newlineDelimiter the chars used for new lines, usually \n, \n\r or \r
   * @param ignoreHeaderLines number of beginning lines to ignore, e.g. headers
   */
  public void sort(
      List&lt;File&gt; inputs,
      File sorted,
      String encoding,
      int column,
      String columnDelimiter,
      Character enclosedBy,
      String newlineDelimiter,
      int ignoreHeaderLines)
      throws IOException {
    Comparator&lt;String&gt; lineComparator;
<span class="fc bfc" id="L681" title="All 2 branches covered.">    if (enclosedBy == null) {</span>
<span class="fc" id="L682">      lineComparator = new LineComparator(column, columnDelimiter);</span>
    } else {
<span class="fc" id="L684">      lineComparator = new LineComparator(column, columnDelimiter, enclosedBy);</span>
    }
<span class="fc" id="L686">    sort(</span>
        inputs,
        sorted,
        encoding,
        column,
        columnDelimiter,
        enclosedBy,
        newlineDelimiter,
        ignoreHeaderLines,
        lineComparator,
        false);
<span class="fc" id="L697">  }</span>

  /**
   * Sorts the input file into the output file using the supplied delimited line parameters.
   *
   * This method is not reliable when the sort field may contain Unicode codepoints outside the Basic Multilingual Plane,
   * i.e. above \uFFFF. In that case, the sort order differs from Java's String sort order.  This should not be a problem
   * for most usage; the Supplementary Multilingual Planes contain ancient scripts, emojis, arrows and so on.
   *
   * This method is globally synchronized, in case multiple sorts are attempted to the same file simultaneously.
   * This could be improved to allow synchronizing against the destination file, rather than for all sorts.
   *
   * @param input To sort
   * @param sorted The sorted version of the input excluding ignored header lines (see ignoreHeaderLines)
   * @param column the column that keeps the values to sort on
   * @param columnDelimiter the delimiter that separates columns in a row
   * @param enclosedBy optional column enclosing character, e.g. a double quote for CSVs
   * @param newlineDelimiter the chars used for new lines, usually \n, \r\n or \r
   * @param ignoreHeaderLines number of beginning lines to ignore, e.g. headers
   * @param lineComparator used to sort the output
   * @param ignoreCase ignore case order, this parameter couldn't have any effect if the LineComparator is used
   */
  public void sort(
      File input,
      File sorted,
      String encoding,
      int column,
      String columnDelimiter,
      Character enclosedBy,
      String newlineDelimiter,
      int ignoreHeaderLines,
      Comparator&lt;String&gt; lineComparator,
      boolean ignoreCase)
      throws IOException {
<span class="nc" id="L731">    sort(</span>
<span class="nc" id="L732">        Collections.singletonList(input),</span>
        sorted,
        encoding,
        column,
        columnDelimiter,
        enclosedBy,
        newlineDelimiter,
        ignoreHeaderLines,
        lineComparator,
        ignoreCase);
<span class="nc" id="L742">  }</span>

  /**
   * Sorts the input file into the output file using the supplied delimited line parameters.
   *
   * This method is not reliable when the sort field may contain Unicode codepoints outside the Basic Multilingual Plane,
   * i.e. above \uFFFF. In that case, the sort order differs from Java's String sort order.  This should not be a problem
   * for most usage; the Supplementary Multilingual Planes contain ancient scripts, emojis, arrows and so on.
   *
   * This method is globally synchronized, in case multiple sorts are attempted to the same file simultaneously.
   * This could be improved to allow synchronizing against the destination file, rather than for all sorts.
   *
   * @param inputs To sort
   * @param sorted The sorted version of the input excluding ignored header lines (see ignoreHeaderLines)
   * @param column the column that keeps the values to sort on
   * @param columnDelimiter the delimiter that separates columns in a row
   * @param enclosedBy optional column enclosing character, e.g. a double quote for CSVs
   * @param newlineDelimiter the chars used for new lines, usually \n, \r\n or \r
   * @param ignoreHeaderLines number of beginning lines to ignore, e.g. headers
   * @param lineComparator used to sort the output
   * @param ignoreCase ignore case order, this parameter couldn't have any effect if the LineComparator is used
   */
  public void sort(
      List&lt;File&gt; inputs,
      File sorted,
      String encoding,
      int column,
      String columnDelimiter,
      Character enclosedBy,
      String newlineDelimiter,
      int ignoreHeaderLines,
      Comparator&lt;String&gt; lineComparator,
      boolean ignoreCase)
      throws IOException {
<span class="fc" id="L776">    LOG.debug(</span>
        &quot;Sorting file(s) {} as new file {}&quot;,
<span class="fc" id="L778">        inputs.stream().map(File::getAbsolutePath),</span>
<span class="fc" id="L779">        sorted.getAbsolutePath());</span>
<span class="pc bpc" id="L780" title="1 of 2 branches missed.">    if (encoding == null) {</span>
<span class="nc" id="L781">      LOG.warn(&quot;No encoding specified, assume UTF-8&quot;);</span>
<span class="nc" id="L782">      encoding = FileUtils.UTF8;</span>
    }
<span class="fc" id="L784">    synchronized (sortLock) {</span>
<span class="pc bpc" id="L785" title="1 of 2 branches missed.">      if (sorted.exists()) {</span>
        // Delete a file, which will allow processes with it open to continue reading it.
        // The GNU sort truncates and appends, which would mean a partial read otherwise.
<span class="fc" id="L788">        LOG.warn(&quot;Deleting existed sorted file {}&quot;, sorted.getAbsoluteFile());</span>
<span class="fc" id="L789">        sorted.delete();</span>
      }
      // if the id is in the first column, first try sorting via shell as its the fastest we can get
<span class="fc bfc" id="L792" title="All 2 branches covered.">      if (!sortInGnu(</span>
          inputs,
          sorted,
          encoding,
          ignoreHeaderLines,
          column,
          columnDelimiter,
          enclosedBy,
          newlineDelimiter,
          ignoreCase)) {
<span class="fc" id="L802">        LOG.debug(&quot;No GNU sort available, using native Java sorting&quot;);</span>
<span class="fc" id="L803">        sortInJava(inputs, sorted, encoding, lineComparator, ignoreHeaderLines);</span>
      }
<span class="fc" id="L805">    }</span>
<span class="fc" id="L806">  }</span>

  /**
   * Sorts the input file into the output file using the supplied lineComparator.
   *
   * @param input To sort
   * @param sorted The sorted version of the input excluding ignored header lines (see ignoreHeaderLines)
   * @param lineComparator To use during comparison
   * @param ignoreHeaderLines number of beginning lines to ignore, e.g. headers
   */
  public void sortInJava(
      File input,
      File sorted,
      String encoding,
      Comparator&lt;String&gt; lineComparator,
      int ignoreHeaderLines)
      throws IOException {
<span class="fc" id="L823">    sortInJava(</span>
<span class="fc" id="L824">        Collections.singletonList(input), sorted, encoding, lineComparator, ignoreHeaderLines);</span>
<span class="fc" id="L825">  }</span>

  /**
   * Sorts the input file into the output file using the supplied lineComparator.
   *
   * @param inputs To sort
   * @param sorted The sorted version of the input excluding ignored header lines (see ignoreHeaderLines)
   * @param lineComparator To use during comparison
   * @param ignoreHeaderLines number of beginning lines to ignore, e.g. headers
   */
  public void sortInJava(
      List&lt;File&gt; inputs,
      File sorted,
      String encoding,
      Comparator&lt;String&gt; lineComparator,
      int ignoreHeaderLines)
      throws IOException {
<span class="fc" id="L842">    LOG.debug(&quot;Sorting file(s) {}&quot;, inputs);</span>
<span class="fc" id="L843">    long start = System.currentTimeMillis();</span>

<span class="fc" id="L845">    List&lt;File&gt; sortFiles = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L846">    List&lt;String&gt; headerLines = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L847" title="All 2 branches covered.">    for (File input : inputs) {</span>
<span class="fc" id="L848">      BufferedReader br =</span>
          new BufferedReader(new InputStreamReader(new FileInputStream(input), encoding));
<span class="fc" id="L850">      int skipHeaderLines = ignoreHeaderLines;</span>
      try {
<span class="fc" id="L852">        String line = br.readLine();</span>
<span class="fc" id="L853">        int fileCount = 0;</span>

<span class="fc" id="L855">        List&lt;String&gt; linesToSort = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L856" title="All 2 branches covered.">        while (line != null) {</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">          if (skipHeaderLines &gt; 0) {</span>
            // Only add the header lines for the first file
<span class="fc bfc" id="L859" title="All 2 branches covered.">            if (headerLines.size() &lt; ignoreHeaderLines) {</span>
<span class="fc" id="L860">              headerLines.add(line);</span>
            }
<span class="fc" id="L862">            skipHeaderLines--;</span>
          } else {
<span class="fc" id="L864">            linesToSort.add(line);</span>

            // if buffer is full, then sort and write to file
<span class="pc bpc" id="L867" title="1 of 2 branches missed.">            if (linesToSort.size() == linesPerMemorySort) {</span>
<span class="nc" id="L868">              sortFiles.add(sortAndWrite(input, encoding, lineComparator, fileCount, linesToSort));</span>
<span class="nc" id="L869">              linesToSort = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L870">              fileCount++;</span>
            }
          }
<span class="fc" id="L873">          line = br.readLine();</span>
        }
        // catch the last lot
<span class="pc bpc" id="L876" title="1 of 2 branches missed.">        if (!linesToSort.isEmpty()) {</span>
<span class="fc" id="L877">          sortFiles.add(sortAndWrite(input, encoding, lineComparator, fileCount, linesToSort));</span>
        }
      } finally {
<span class="fc" id="L880">        br.close();</span>
      }
<span class="fc" id="L882">    }</span>
<span class="fc" id="L883">    LOG.debug(</span>
<span class="fc" id="L884">        sortFiles.size()</span>
            + &quot; sorted file chunks created in &quot;
<span class="fc" id="L886">            + (System.currentTimeMillis() - start) / 1000</span>
            + &quot; secs&quot;);

    // now merge the sorted files into one single sorted file
<span class="fc" id="L890">    Writer sortedFileWriter = new BufferedWriter(new FileWriter(sorted));</span>
    // first write the old header lines if existing
<span class="fc bfc" id="L892" title="All 2 branches covered.">    for (String h : headerLines) {</span>
<span class="fc" id="L893">      sortedFileWriter.write(h);</span>
<span class="fc" id="L894">      sortedFileWriter.write(&quot;\n&quot;);</span>
<span class="fc" id="L895">    }</span>
<span class="fc" id="L896">    mergeSortedFiles(sortFiles, sortedFileWriter, lineComparator);</span>

<span class="fc" id="L898">    LOG.debug(</span>
        &quot;Fils(s) {} sorted successfully using {} parts to do sorting in {}s&quot;,
<span class="fc" id="L900">        inputs.stream().map(File::getAbsolutePath),</span>
<span class="fc" id="L901">        sortFiles.size(),</span>
<span class="fc" id="L902">        (System.currentTimeMillis() - start) / 1000);</span>
<span class="fc" id="L903">  }</span>

  /**
   * Splits the supplied file into files of set line size and with a suffix.
   *
   * @param input To split up
   * @param linesPerOutput Lines per split file
   * @param extension The file extension to use - e.g. &quot;.txt&quot;
   * @return The split files
   */
  public List&lt;File&gt; split(File input, int linesPerOutput, String extension) throws IOException {
<span class="nc" id="L914">    LOG.debug(&quot;Splitting File[&quot; + input.getAbsolutePath() + ']');</span>
<span class="nc" id="L915">    long timer = System.currentTimeMillis();</span>
<span class="nc" id="L916">    List&lt;File&gt; splitFiles = new LinkedList&lt;&gt;();</span>
    // Use ISO-8859-1 as a binary-safe encoding.
<span class="nc" id="L918">    BufferedReader br =</span>
        new BufferedReader(
            new InputStreamReader(new FileInputStream(input), StandardCharsets.ISO_8859_1));
<span class="nc" id="L921">    String line = br.readLine();</span>
<span class="nc" id="L922">    int fileCount = 0;</span>
<span class="nc" id="L923">    File splitFile = getChunkFile(input, fileCount);</span>
<span class="nc" id="L924">    fileCount++;</span>
<span class="nc" id="L925">    splitFiles.add(splitFile);</span>
<span class="nc" id="L926">    OutputStreamWriter fw =</span>
        new OutputStreamWriter(new FileOutputStream(splitFile), StandardCharsets.ISO_8859_1);
    try {
<span class="nc" id="L929">      int lineCount = 0;</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">      while (line != null) {</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">        if (lineCount == linesPerOutput) {</span>
<span class="nc" id="L932">          fw.flush();</span>
<span class="nc" id="L933">          fw.close();</span>
<span class="nc" id="L934">          splitFile = getChunkFile(input, fileCount);</span>
<span class="nc" id="L935">          splitFiles.add(splitFile);</span>
          // is ok to reuse, as last one is closed, and this will always get closed - see finally
          // below
<span class="nc" id="L938">          fw = new OutputStreamWriter(new FileOutputStream(splitFile), StandardCharsets.ISO_8859_1);</span>
<span class="nc" id="L939">          fileCount++;</span>
<span class="nc" id="L940">          lineCount = 0;</span>
        }
<span class="nc" id="L942">        fw.write(line);</span>
<span class="nc" id="L943">        fw.write(&quot;\n&quot;);</span>
<span class="nc" id="L944">        line = br.readLine();</span>
<span class="nc" id="L945">        lineCount++;</span>
      }
<span class="nc" id="L947">      fw.flush();</span>
    } finally {
<span class="nc" id="L949">      fw.close();</span>
    }
<span class="nc" id="L951">    LOG.debug(</span>
        &quot;File[&quot;
<span class="nc" id="L953">            + input.getAbsolutePath()</span>
            + &quot;] split successfully into[&quot;
<span class="nc" id="L955">            + splitFiles.size()</span>
            + &quot;] parts in secs[&quot;
<span class="nc" id="L957">            + (1 + System.currentTimeMillis() - timer) / 1000</span>
            + &quot;]&quot;);
<span class="nc" id="L959">    return splitFiles;</span>
  }

  /**
   * Test whether we have a new enough version of GNU Sort that supports (primarily) the -k option with a start and end
   * column.
   *
   * Mac OS only includes an old version of GNU sort, and will fail this test.
   */
  private boolean gnuSortAvailable() {
<span class="fc bfc" id="L969" title="All 2 branches covered.">    if (gnuSortAvailable != null) {</span>
<span class="fc" id="L970">      return gnuSortAvailable;</span>
    }

    try {
<span class="fc" id="L974">      String command = &quot;sort -k1,1 -t',' --ignore-case /dev/null&quot;;</span>
<span class="fc" id="L975">      LOG.debug(&quot;Testing capability of 'sort' with command: {}&quot;, command);</span>

<span class="fc" id="L977">      Process process = new ProcessBuilder(&quot;/bin/sh&quot;, &quot;-c&quot;, command).start();</span>
<span class="fc" id="L978">      int exitValue = process.waitFor();</span>

<span class="pc bpc" id="L980" title="1 of 2 branches missed.">      if (exitValue == 0) {</span>
<span class="fc" id="L981">        LOG.debug(&quot;GNU sort is capable&quot;);</span>
<span class="fc" id="L982">        gnuSortAvailable = true;</span>
      } else {
<span class="nc" id="L984">        LOG.warn(</span>
            &quot;GNU sort does not exist or is too old, and will not be used.  Sorting large files will be slow.&quot;,
<span class="nc" id="L986">            new InputStreamUtils().readEntireStream(process.getErrorStream()).replace('\n', ' '));</span>
<span class="nc" id="L987">        gnuSortAvailable = false;</span>
      }
<span class="nc" id="L989">    } catch (Exception e) {</span>
<span class="nc" id="L990">      LOG.warn(</span>
          &quot;GNU sort does not exist or is too old, and will not be used.  Sorting large files will be slow.&quot;,
          e);
<span class="nc" id="L993">      gnuSortAvailable = false;</span>
<span class="fc" id="L994">    }</span>

<span class="fc" id="L996">    return gnuSortAvailable;</span>
  }

  /**
   * sort a text file via an external GNU sort command:
   * sorting tabs at 3rd column, numerical reverse order
   * sort -t$'\t' -k3 -o sorted.txt col2007.txt
   * &lt;p/&gt;
   * The GNU sort based sorting is extremely efficient and much, much faster than the current sortInJava method. It is
   * locale aware though and we only want the native C sorting locale. See
   * http://www.gnu.org/software/coreutils/faq/coreutils-faq.html#Sort-does-not-sort-in-normal-order_0021
   * &lt;p/&gt;
   * Example C sort order:
   * &lt;p/&gt;
   * &lt;pre&gt;
   * 1 oOdontoceti
   * 10 gGlobicephala melaena melaena Traill
   * 100 gGlobicephala melaena melaena Traill
   * 101 gGlobicephala melaena melaena Traill
   * 11 pPontoporia Gray
   * 12 pPontoporia blainvillei Gervais and d'Orbigny
   * 120 iInia d'Orbigny
   * 121 iInia geoffrensis Blainville
   * 2 sSusuidae
   * 20 cCetacea
   * Amphiptera
   * Amphiptera pacifica Giglioli
   * Anarnak Lacépède
   * Balaena mangidach Chamisso
   * amphiptera
   * amphiptera pacifica Giglioli
   * anarnak Lacépède
   * balaena mangidach Chamisso
   * &lt;/pre&gt;
   */
  protected boolean sortInGnu(
      List&lt;File&gt; inputs,
      File sorted,
      String encoding,
      int ignoreHeaderLines,
      int column,
      String columnDelimiter,
      Character enclosedBy,
      String lineDelimiter,
      boolean ignoreCase)
      throws IOException {
    String command;
    // GNU sort is available for use when:
    // • line delimiter is \n
    // • no enclosed by/quote character is in use
    // • sorting is using the first column
    // • sort version is sufficient to include start and end column (-k 1,1).
    // Use the --debug option to sort if working on this code.
<span class="pc bpc" id="L1049" title="1 of 4 branches missed.">    if (lineDelimiter == null || !lineDelimiter.contains(&quot;\n&quot;)) {</span>
<span class="fc" id="L1050">      LOG.debug(&quot;Cannot use GNU sort on this file: line delimiter does not contain newline.&quot;);</span>
<span class="fc" id="L1051">      return false;</span>
<span class="pc bpc" id="L1052" title="1 of 4 branches missed.">    } else if (columnDelimiter != null &amp;&amp; column &gt; 0) {</span>
<span class="fc" id="L1053">      LOG.debug(&quot;Cannot use GNU sort on this file: sort column is not the first.&quot;);</span>
<span class="fc" id="L1054">      return false;</span>
<span class="fc bfc" id="L1055" title="All 2 branches covered.">    } else if (enclosedBy != null) {</span>
<span class="fc" id="L1056">      LOG.debug(&quot;Cannot use GNU sort on this file: enclosed by character set.&quot;);</span>
<span class="fc" id="L1057">      return false;</span>
<span class="pc bpc" id="L1058" title="1 of 2 branches missed.">    } else if (!gnuSortAvailable()) {</span>
<span class="nc" id="L1059">      LOG.debug(&quot;Cannot use GNU sort on this file: command unavailable.&quot;);</span>
<span class="nc" id="L1060">      return false;</span>
    }

    // keep header rows
<span class="fc" id="L1064">    boolean success = false;</span>
    try {
<span class="fc" id="L1066">      LinkedList&lt;String&gt; cmds = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L1067">      cmds.add(&quot;/bin/sh&quot;);</span>
<span class="fc" id="L1068">      cmds.add(&quot;-c&quot;);</span>
<span class="fc" id="L1069">      cmds.add(&quot;&quot;);</span>
<span class="fc" id="L1070">      ProcessBuilder pb = new ProcessBuilder(cmds);</span>
<span class="fc" id="L1071">      Map&lt;String, String&gt; env = pb.environment();</span>

      // clear the environment, but keep specified temp working directory
<span class="pc bpc" id="L1074" title="1 of 2 branches missed.">      env.keySet().removeIf(key -&gt; !(key.equals(&quot;TMPDIR&quot;)));</span>
<span class="pc bpc" id="L1075" title="1 of 2 branches missed.">      if (System.getProperty(&quot;java.io.tmpdir&quot;) != null) {</span>
<span class="fc" id="L1076">        env.put(&quot;TMPDIR&quot;, System.getProperty(&quot;java.io.tmpdir&quot;));</span>
      }
      // make sure we use the C locale for sorting
<span class="fc" id="L1079">      env.put(&quot;LC_ALL&quot;, &quot;C&quot;);</span>

<span class="fc" id="L1081">      String sortArgs =</span>
<span class="fc" id="L1082">          String.format(</span>
              &quot; %s -k%d,%d -t'%s'&quot;,
<span class="pc bpc" id="L1084" title="1 of 2 branches missed.">              ignoreCase ? &quot;--ignore-case&quot; : &quot;&quot;, column + 1, column + 1, columnDelimiter);</span>

<span class="fc" id="L1086">      String fileList = inputs.stream().map(File::getAbsolutePath).collect(Collectors.joining(&quot; &quot;));</span>
<span class="fc bfc" id="L1087" title="All 2 branches covered.">      if (ignoreHeaderLines &gt; 0) {</span>
        // copy header lines
<span class="fc" id="L1089">        command =</span>
            &quot;head -n &quot;
                + ignoreHeaderLines
                + ' '
<span class="fc" id="L1093">                + inputs.get(0).getAbsolutePath()</span>
                + &quot; &gt; &quot;
<span class="fc" id="L1095">                + sorted.getAbsolutePath();</span>
<span class="fc" id="L1096">        LOG.debug(&quot;Issue external command: {}&quot;, command);</span>
<span class="fc" id="L1097">        cmds.removeLast();</span>
<span class="fc" id="L1098">        cmds.add(command);</span>
<span class="fc" id="L1099">        Process process = pb.start();</span>
<span class="fc" id="L1100">        int exitValue = process.waitFor();</span>
<span class="pc bpc" id="L1101" title="1 of 2 branches missed.">        if (exitValue != 0) {</span>
<span class="nc" id="L1102">          LOG.warn(&quot;Error sorting file (copying header lines) with GNU head&quot;);</span>
<span class="nc" id="L1103">          return false;</span>
        }

        // do the sorting ignoring the header rows
<span class="fc" id="L1107">        command =</span>
            &quot;tail -q -n +&quot;
                + (ignoreHeaderLines + 1)
                + &quot; &quot;
                + fileList
                + &quot; | &quot;
                + &quot;sort &quot;
                + sortArgs
                + &quot; &gt;&gt; &quot;
<span class="fc" id="L1116">                + sorted.getAbsolutePath();</span>
<span class="fc" id="L1117">      } else {</span>
        // do sorting directly, we don't have header rows
<span class="fc" id="L1119">        command = &quot;sort &quot; + sortArgs + &quot; -o &quot; + sorted.getAbsolutePath() + ' ' + fileList;</span>
      }

<span class="fc" id="L1122">      LOG.debug(&quot;Issue external command: {}&quot;, command);</span>
<span class="fc" id="L1123">      cmds.removeLast();</span>
<span class="fc" id="L1124">      cmds.add(command);</span>
<span class="fc" id="L1125">      Process process = pb.start();</span>
      // get the stdout and stderr from the command that was run
<span class="fc" id="L1127">      InputStream err = process.getErrorStream();</span>
<span class="fc" id="L1128">      int exitValue = process.waitFor();</span>
<span class="fc bfc" id="L1129" title="All 2 branches covered.">      if (exitValue == 0) {</span>
<span class="fc" id="L1130">        LOG.debug(&quot;Successfully sorted file with GNU sort&quot;);</span>
<span class="fc" id="L1131">        success = true;</span>
      } else {
<span class="fc" id="L1133">        LOG.warn(&quot;Error sorting file with GNU sort&quot;);</span>
<span class="fc" id="L1134">        InputStreamUtils isu = new InputStreamUtils();</span>
<span class="fc" id="L1135">        System.err.append(isu.readEntireStream(err));</span>
      }
<span class="nc" id="L1137">    } catch (Exception e) {</span>
<span class="nc" id="L1138">      LOG.warn(&quot;Caught Exception using GNU sort&quot;, e);</span>
<span class="fc" id="L1139">    }</span>
<span class="fc" id="L1140">    return success;</span>
  }

  /**
   * Sorts the lines and writes to file using the
   *
   * @param input File to base the name on
   * @param lineComparator To compare the lines for sorting
   * @param fileCount Used for the file name
   * @param linesToSort To actually sort
   * @return The written file
   */
  private File sortAndWrite(
      File input,
      String encoding,
      Comparator&lt;String&gt; lineComparator,
      int fileCount,
      List&lt;String&gt; linesToSort)
      throws IOException {
<span class="fc" id="L1159">    long start = System.currentTimeMillis();</span>
<span class="fc" id="L1160">    linesToSort.sort(lineComparator);</span>
    // When implementing a comparator, make it SUPER quick!!!
<span class="fc" id="L1162">    LOG.debug(</span>
        &quot;Collections.sort took msec[&quot;
<span class="fc" id="L1164">            + (System.currentTimeMillis() - start)</span>
            + &quot;] to sort records[&quot;
<span class="fc" id="L1166">            + linesToSort.size()</span>
            + ']');
<span class="fc" id="L1168">    File sortFile = getChunkFile(input, fileCount);</span>
<span class="fc" id="L1169">    try (Writer fw = new OutputStreamWriter(new FileOutputStream(sortFile), encoding)) {</span>
<span class="fc bfc" id="L1170" title="All 2 branches covered.">      for (String s : linesToSort) {</span>
<span class="fc" id="L1171">        fw.write(s);</span>
<span class="fc" id="L1172">        fw.write(&quot;\n&quot;);</span>
<span class="fc" id="L1173">      }</span>
    }
<span class="fc" id="L1175">    return sortFile;</span>
  }

  /**
   * Creates an empty file or updates the last updated timestamp on the same as the unix command of
   * the same name.
   *
   * &lt;p&gt;From Guava.
   *
   * @param file the file to create or update
   * @throws IOException if an I/O error occurs
   */
  public static void touch(File file) throws IOException {
<span class="fc" id="L1188">    Objects.requireNonNull(file);</span>
<span class="pc bpc" id="L1189" title="3 of 4 branches missed.">    if (!file.createNewFile() &amp;&amp; !file.setLastModified(System.currentTimeMillis())) {</span>
<span class="nc" id="L1190">      throw new IOException(&quot;Unable to update modification time of &quot; + file);</span>
    }
<span class="fc" id="L1192">  }</span>

  /**
   * Returns the &lt;a href=&quot;http://en.wikipedia.org/wiki/Filename_extension&quot;&gt;file extension&lt;/a&gt; for
   * the given file name, or the empty string if the file has no extension. The result does not
   * include the '{@code .}'.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This method simply returns everything after the last '{@code .}' in the file's
   * name as determined by {@link File#getName}. It does not account for any filesystem-specific
   * behavior that the {@link File} API does not already account for. For example, on NTFS it will
   * report {@code &quot;txt&quot;} as the extension for the filename {@code &quot;foo.exe:.txt&quot;} even though NTFS
   * will drop the {@code &quot;:.txt&quot;} part of the name when the file is actually created on the
   * filesystem due to NTFS's &lt;a href=&quot;https://goo.gl/vTpJi4&quot;&gt;Alternate Data Streams&lt;/a&gt;.
   *
   * &lt;p&gt;From Guava.
   */
  public static String getFileExtension(String fullName) {
<span class="fc" id="L1209">    Objects.requireNonNull(fullName);</span>
<span class="fc" id="L1210">    String fileName = new File(fullName).getName();</span>
<span class="fc" id="L1211">    int dotIndex = fileName.lastIndexOf('.');</span>
<span class="pc bpc" id="L1212" title="1 of 2 branches missed.">    return (dotIndex == -1) ? &quot;&quot; : fileName.substring(dotIndex + 1);</span>
  }

  /**
   * Creates any necessary but nonexistent parent directories of the specified file. Note that if
   * this operation fails it may have succeeded in creating some (but not all) of the necessary
   * parent directories.
   *
   * &lt;p&gt;From Guava.
   *
   * @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent
   *     directories of the specified file could not be created.
   */
  public static void createParentDirs(File file) throws IOException {
<span class="fc" id="L1226">    Objects.requireNonNull(file);</span>
<span class="fc" id="L1227">    File parent = file.getCanonicalFile().getParentFile();</span>
<span class="pc bpc" id="L1228" title="1 of 2 branches missed.">    if (parent == null) {</span>
      /*
       * The given directory is a filesystem root. All zero of its ancestors exist. This doesn't
       * mean that the root itself exists -- consider x:\ on a Windows machine without such a drive
       * -- or even that the caller can create it, but this method makes no such guarantees even for
       * non-root files.
       */
<span class="nc" id="L1235">      return;</span>
    }
    //noinspection ResultOfMethodCallIgnored
<span class="fc" id="L1238">    parent.mkdirs();</span>
<span class="pc bpc" id="L1239" title="1 of 2 branches missed.">    if (!parent.isDirectory()) {</span>
<span class="nc" id="L1240">      throw new IOException(&quot;Unable to create parent directories of &quot; + file);</span>
    }
<span class="fc" id="L1242">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>