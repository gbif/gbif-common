<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GBIF Common</a> &gt; <a href="index.source.html" class="el_package">org.gbif.utils.file</a> &gt; <span class="el_source">FileUtils.java</span></div><h1>FileUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gbif.utils.file;

import org.gbif.utils.collection.CompactHashSet;
import org.gbif.utils.text.LineComparator;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Pattern;

import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.LineIterator;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Collection of file utils.
 * &lt;br&gt;
 * This class has only been tested for use with a UTF-8 system encoding.
 */
<span class="fc" id="L59">public final class FileUtils {</span>

<span class="fc" id="L61">  private static final Logger LOG = LoggerFactory.getLogger(FileUtils.class);</span>

<span class="fc" id="L63">  public static final String UTF8 = StandardCharsets.UTF_8.name();</span>
<span class="fc" id="L64">  public static final Pattern TAB_DELIMITED = Pattern.compile(&quot;\t&quot;);</span>
<span class="fc" id="L65">  private static int linesPerMemorySort = 100000;</span>
<span class="fc" id="L66">  private static Boolean gnuSortAvailable = null;</span>
<span class="fc" id="L67">  private static final Object sortLock = new Object();</span>

  static {
    /* Warn when the software is not run in a Unicode environment.  This library has not been
     * tested to run in a non-Unicode environment, and may cause data corruption.
     */
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">    if (Charset.defaultCharset().equals(StandardCharsets.US_ASCII)) {</span>
<span class="nc" id="L74">      System.err.println(</span>
          &quot;The default character set is US ASCII.  It is strongly recommended to &quot;
              + &quot;run this software in a Unicode environment.&quot;);
    }
<span class="fc" id="L78">  }</span>

  public static String classpath2Filepath(String path) {
<span class="nc" id="L81">    return new File(ClassLoader.getSystemResource(path).getFile()).getAbsolutePath();</span>
  }

  public static InputStream classpathStream(String path) throws IOException {
<span class="fc" id="L85">    InputStream in = null;</span>
    // relative path. Use classpath instead
<span class="fc" id="L87">    URL url = FileUtils.class.getClassLoader().getResource(path);</span>
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">    if (url != null) {</span>
<span class="fc" id="L89">      in = url.openStream();</span>
    }
<span class="fc" id="L91">    return in;</span>
  }

  public static Set&lt;String&gt; columnsToSet(InputStream source, int... column) throws IOException {
<span class="nc" id="L95">    return columnsToSet(source, new CompactHashSet&lt;String&gt;(), column);</span>
  }

  /**
   * Reads a file and returns a unique set of multiple columns from lines which are no comments (starting with #) and
   * trims whitespace.
   *
   * @param source the UTF-8 encoded text file with tab delimited columns
   * @param resultSet the set implementation to be used. Will not be cleared before reading!
   * @param column variable length argument of column indices to process
   * @return set of column rows
   */
  public static Set&lt;String&gt; columnsToSet(InputStream source, Set&lt;String&gt; resultSet, int... column)
      throws IOException {
<span class="nc" id="L109">    LineIterator lines = getLineIterator(source);</span>
<span class="nc" id="L110">    int maxCols = 0;</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">    for (int c : column) {</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">      if (c &gt; maxCols) {</span>
<span class="nc" id="L113">        maxCols = c;</span>
      }
    }
<span class="nc bnc" id="L116" title="All 2 branches missed.">    while (lines.hasNext()) {</span>
<span class="nc" id="L117">      String line = lines.nextLine().trim();</span>
      // ignore comments
<span class="nc bnc" id="L119" title="All 2 branches missed.">      if (!ignore(line)) {</span>
<span class="nc" id="L120">        String[] parts = TAB_DELIMITED.split(line);</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">        if (maxCols &lt;= parts.length) {</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">          for (int c : column) {</span>
<span class="nc" id="L123">            String cell = parts[c].trim();</span>
<span class="nc" id="L124">            resultSet.add(cell);</span>
          }
        }
      }
<span class="nc" id="L128">    }</span>
<span class="nc" id="L129">    return resultSet;</span>
  }

  public static void copyStreams(InputStream in, OutputStream out) throws IOException {
    // write the file to the file specified
    int bytesRead;
<span class="nc" id="L135">    byte[] buffer = new byte[8192];</span>

<span class="nc bnc" id="L137" title="All 2 branches missed.">    while ((bytesRead = in.read(buffer, 0, 8192)) != -1) {</span>
<span class="nc" id="L138">      out.write(buffer, 0, bytesRead);</span>
    }

<span class="nc" id="L141">    out.close();</span>
<span class="nc" id="L142">    in.close();</span>
<span class="nc" id="L143">  }</span>

  public static void copyStreamToFile(InputStream in, File out) throws IOException {
<span class="nc" id="L146">    copyStreams(in, new FileOutputStream(out));</span>
<span class="nc" id="L147">  }</span>

  public static File createTempDir() throws IOException {
<span class="fc" id="L150">    return createTempDir(&quot;gbif-futil&quot;, &quot;.tmp&quot;);</span>
  }

  /**
   * @param prefix The prefix string to be used in generating the file's name; must be at least three characters long
   * @param suffix The suffix string to be used in generating the file's name; may be null, in which case the suffix
   *        &quot;.tmp&quot; will be used
   */
  public static File createTempDir(String prefix, String suffix) throws IOException {
<span class="fc" id="L159">    File dir = File.createTempFile(prefix, suffix);</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">    if (!dir.delete()) {</span>
<span class="nc" id="L161">      throw new IOException(&quot;Could not delete temp file: &quot; + dir.getAbsolutePath());</span>
    }
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">    if (!dir.mkdir()) {</span>
<span class="nc" id="L164">      throw new IOException(&quot;Could not create temp directory: &quot; + dir.getAbsolutePath());</span>
    }
<span class="fc" id="L166">    return dir;</span>
  }

  /**
   * Delete directory recursively, including all its files, sub-folders, and sub-folder's files.
   *
   * @param directory directory to delete recursively
   */
  public static void deleteDirectoryRecursively(File directory) {
<span class="nc" id="L175">    File[] list = directory.listFiles();</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">    for (File file : list) {</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">      if (file.isDirectory()) {</span>
<span class="nc" id="L178">        deleteDirectoryRecursively(file);</span>
<span class="nc" id="L179">        file.delete();</span>
      } else {
<span class="nc" id="L181">        file.delete();</span>
      }
    }
<span class="nc" id="L184">    directory.delete();</span>
<span class="nc" id="L185">  }</span>

  /**
   * Escapes a filename so it is a valid filename on all systems, replacing /. .. \t\r\n.
   *
   * @param filename to be escaped
   */
  public static String escapeFilename(String filename) {
<span class="nc" id="L193">    return filename.replaceAll(&quot;[\\s./&amp;]&quot;, &quot;_&quot;);</span>
  }

  public static File getClasspathFile(String path) {
<span class="fc" id="L197">    return new File(ClassLoader.getSystemResource(path).getFile());</span>
  }

  public static InputStream getInputStream(File source) throws FileNotFoundException {
<span class="fc" id="L201">    return new FileInputStream(source);</span>
  }

  public static BufferedReader getInputStreamReader(InputStream input)
      throws FileNotFoundException {
<span class="nc" id="L206">    return getInputStreamReader(input, UTF8);</span>
  }

  public static BufferedReader getInputStreamReader(InputStream input, String encoding)
      throws FileNotFoundException {
<span class="nc" id="L211">    BufferedReader reader = null;</span>
    try {
<span class="nc" id="L213">      reader = new BufferedReader(new InputStreamReader(input, encoding));</span>
<span class="nc" id="L214">    } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L215">      LOG.warn(&quot;Caught Exception&quot;, e);</span>
<span class="nc" id="L216">    }</span>
<span class="nc" id="L217">    return reader;</span>
  }

  /**
   * @param source the source input stream encoded in UTF-8
   */
  public static LineIterator getLineIterator(InputStream source) {
<span class="nc" id="L224">    return getLineIterator(source, UTF8);</span>
  }

  /**
   * @param source the source input stream
   * @param encoding the encoding used by the input stream
   */
  public static LineIterator getLineIterator(InputStream source, String encoding) {
    try {
<span class="nc" id="L233">      return new LineIterator(new BufferedReader(new InputStreamReader(source, encoding)));</span>
<span class="nc" id="L234">    } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L235">      throw new IllegalArgumentException(&quot;Unsupported encoding&quot; + encoding, e);</span>
    }
  }

  public static BufferedReader getUtf8Reader(File file) throws FileNotFoundException {
<span class="nc" id="L240">    BufferedReader reader = null;</span>
    try {
<span class="nc" id="L242">      reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), UTF8));</span>
<span class="nc" id="L243">    } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L244">      LOG.warn(&quot;Caught Exception&quot;, e);</span>
<span class="nc" id="L245">    }</span>
<span class="nc" id="L246">    return reader;</span>
  }

  /**
   * Converts the byte size into human-readable format.
   * Support both SI and byte format.
   */
  public static String humanReadableByteCount(long bytes, boolean si) {
<span class="fc bfc" id="L254" title="All 2 branches covered.">    int unit = si ? 1000 : 1024;</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">    if (bytes &lt; unit) {</span>
<span class="fc" id="L256">      return bytes + &quot; B&quot;;</span>
    }
<span class="fc" id="L258">    int exp = (int) (Math.log(bytes) / Math.log(unit));</span>
<span class="fc bfc" id="L259" title="All 4 branches covered.">    String pre = (si ? &quot;kMGTPE&quot; : &quot;KMGTPE&quot;).charAt(exp - 1) + (si ? &quot;&quot; : &quot;i&quot;);</span>
<span class="fc" id="L260">    return String.format(&quot;%.1f %sB&quot;, bytes / Math.pow(unit, exp), pre);</span>
  }

  public static boolean isCompressedFile(File source) {
<span class="nc" id="L264">    String suffix = source.getName().substring(source.getName().lastIndexOf('.') + 1);</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">    return suffix != null</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">        &amp;&amp; suffix.length() &gt; 0</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">        &amp;&amp; (&quot;zip&quot;.equalsIgnoreCase(suffix)</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">            || &quot;tgz&quot;.equalsIgnoreCase(suffix)</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">            || &quot;gz&quot;.equalsIgnoreCase(suffix));</span>
  }

  /**
   * Reads a complete file into a byte buffer.
   */
  public static ByteBuffer readByteBuffer(File file) throws IOException {
<span class="fc" id="L276">    byte[] content = org.apache.commons.io.FileUtils.readFileToByteArray(file);</span>
<span class="fc" id="L277">    return ByteBuffer.wrap(content);</span>
  }

  /**
   * Reads the first bytes of a file into a byte buffer.
   *
   * @param bufferSize the number of bytes to read from the file
   */
  public static ByteBuffer readByteBuffer(File file, int bufferSize) throws IOException {
<span class="fc" id="L286">    ByteBuffer bbuf = ByteBuffer.allocate(bufferSize);</span>
<span class="fc" id="L287">    BufferedInputStream f = new BufferedInputStream(new FileInputStream(file), bufferSize);</span>

    int b;
<span class="fc bfc" id="L290" title="All 2 branches covered.">    while ((b = f.read()) != -1) {</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">      if (!bbuf.hasRemaining()) {</span>
<span class="fc" id="L292">        break;</span>
      }
<span class="fc" id="L294">      bbuf.put((byte) b);</span>
    }
<span class="fc" id="L296">    f.close();</span>

<span class="fc" id="L298">    return bbuf;</span>
  }

  /**
   * @param linesPerMemorySort are the number of lines that should be sorted in memory, determining the number of file
   *        segments to be sorted when doing a Java file sort. Defaults to 100000, if you have
   *        memory available a higher value increases performance.
   */
  public static void setLinesPerMemorySort(int linesPerMemorySort) {
<span class="nc" id="L307">    FileUtils.linesPerMemorySort = linesPerMemorySort;</span>
<span class="nc" id="L308">  }</span>

  public static Writer startNewUtf8File(File file) throws IOException {
<span class="nc" id="L311">    touch(file);</span>
<span class="nc" id="L312">    return new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file, false), UTF8));</span>
  }

  public static Writer startNewUtf8XmlFile(File file) throws IOException {
<span class="nc" id="L316">    Writer writer = startNewUtf8File(file);</span>
<span class="nc" id="L317">    writer.write(&quot;&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&quot;);</span>
<span class="nc" id="L318">    return writer;</span>
  }

  /**
   * Takes a utf8 encoded input stream and reads in every line/row into a list.
   *
   * @return list of rows
   */
  public static LinkedList&lt;String&gt; streamToList(InputStream source) throws IOException {
<span class="fc" id="L327">    return streamToList(source, FileUtils.UTF8);</span>
  }

  /**
   * Reads a file and returns a list of all lines which are no comments (starting with #) and trims whitespace.
   *
   * @param source the UTF-8 encoded text file to read
   * @param resultList the list implementation to be used. Will not be cleared before reading!
   * @return list of lines
   */
  public static List&lt;String&gt; streamToList(InputStream source, List&lt;String&gt; resultList)
      throws IOException {
<span class="nc" id="L339">    LineIterator lines = getLineIterator(source);</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">    while (lines.hasNext()) {</span>
<span class="nc" id="L341">      String line = lines.nextLine().trim();</span>
      // ignore comments
<span class="nc bnc" id="L343" title="All 2 branches missed.">      if (!ignore(line)) {</span>
<span class="nc" id="L344">        resultList.add(line);</span>
      }
<span class="nc" id="L346">    }</span>
<span class="nc" id="L347">    return resultList;</span>
  }

  public static LinkedList&lt;String&gt; streamToList(InputStream source, String encoding)
      throws IOException {
<span class="fc" id="L352">    LinkedList&lt;String&gt; resultList = new LinkedList&lt;&gt;();</span>
    try {
<span class="fc" id="L354">      LineIterator lines =</span>
          new LineIterator(new BufferedReader(new InputStreamReader(source, encoding)));
<span class="fc bfc" id="L356" title="All 2 branches covered.">      while (lines.hasNext()) {</span>
<span class="fc" id="L357">        String line = lines.nextLine();</span>
<span class="fc" id="L358">        resultList.add(line);</span>
<span class="fc" id="L359">      }</span>
<span class="nc" id="L360">    } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L361">      throw new IllegalArgumentException(&quot;Unsupported encoding &quot; + encoding, e);</span>
<span class="fc" id="L362">    }</span>
<span class="fc" id="L363">    return resultList;</span>
  }

  /**
   * Reads a utf8 encoded inut stream, splits
   */
  public static Map&lt;String, String&gt; streamToMap(InputStream source) throws IOException {
<span class="nc" id="L370">    return streamToMap(source, new HashMap&lt;&gt;());</span>
  }

  public static Map&lt;String, String&gt; streamToMap(
      InputStream source, int key, int value, boolean trimToNull) throws IOException {
<span class="nc" id="L375">    return streamToMap(source, new HashMap&lt;&gt;(), key, value, trimToNull);</span>
  }

  /**
   * Read a hashmap from a tab delimited utf8 input stream using the row number as an integer value and the entire row
   * as the value. Ignores commented rows starting with #.
   *
   * @param source tab delimited text file to read
   */
  public static Map&lt;String, String&gt; streamToMap(InputStream source, Map&lt;String, String&gt; result)
      throws IOException {
<span class="nc" id="L386">    LineIterator lines = getLineIterator(source);</span>
<span class="nc" id="L387">    Integer row = 0;</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">    while (lines.hasNext()) {</span>
<span class="nc" id="L389">      row++;</span>
<span class="nc" id="L390">      String line = lines.nextLine().trim();</span>
      // ignore comments
<span class="nc bnc" id="L392" title="All 2 branches missed.">      if (!ignore(line)) {</span>
<span class="nc" id="L393">        result.put(line, row.toString());</span>
      }
<span class="nc" id="L395">    }</span>
<span class="nc" id="L396">    return result;</span>
  }

  /**
   * Read a hashmap from a tab delimited utf8 file, ignoring commented rows starting with #.
   *
   * @param source tab delimited input stream to read
   * @param key column number to use as key
   * @param value column number to use as value
   * @param trimToNull if true trims map entries to null
   */
  public static Map&lt;String, String&gt; streamToMap(
      InputStream source, Map&lt;String, String&gt; result, int key, int value, boolean trimToNull)
      throws IOException {
<span class="nc" id="L410">    LineIterator lines = getLineIterator(source);</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">    int maxCols = key &gt; value ? key : value + 1;</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">    while (lines.hasNext()) {</span>
<span class="nc" id="L413">      String line = lines.nextLine();</span>
      // ignore comments
<span class="nc bnc" id="L415" title="All 2 branches missed.">      if (!ignore(line)) {</span>
<span class="nc" id="L416">        String[] parts = TAB_DELIMITED.split(line);</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">        if (maxCols &lt;= parts.length) {</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">          if (trimToNull) {</span>
<span class="nc" id="L419">            result.put(StringUtils.trimToNull(parts[key]), StringUtils.trimToNull(parts[value]));</span>
          } else {
<span class="nc" id="L421">            result.put(parts[key], parts[value]);</span>
          }
        }
      }
<span class="nc" id="L425">    }</span>
<span class="nc" id="L426">    return result;</span>
  }

  public static Set&lt;String&gt; streamToSet(InputStream source) throws IOException {
<span class="nc" id="L430">    return streamToSet(source, new CompactHashSet&lt;&gt;());</span>
  }

  /**
   * Reads a file and returns a unique set of all lines which are no comments (starting with #) and trims whitespace.
   *
   * @param source the UTF-8 encoded text file to read
   * @param resultSet the set implementation to be used. Will not be cleared before reading!
   * @return set of unique lines
   */
  public static Set&lt;String&gt; streamToSet(InputStream source, Set&lt;String&gt; resultSet)
      throws IOException {
<span class="nc" id="L442">    LineIterator lines = getLineIterator(source);</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">    while (lines.hasNext()) {</span>
<span class="nc" id="L444">      String line = lines.nextLine().trim();</span>
      // ignore comments
<span class="nc bnc" id="L446" title="All 2 branches missed.">      if (!ignore(line)) {</span>
<span class="nc" id="L447">        resultSet.add(line);</span>
      }
<span class="nc" id="L449">    }</span>
<span class="nc" id="L450">    return resultSet;</span>
  }

  public static String toFilePath(URL url) {
    String protocol =
<span class="pc bpc" id="L455" title="1 of 4 branches missed.">        url.getProtocol() == null || &quot;http&quot;.equalsIgnoreCase(url.getProtocol())</span>
<span class="fc" id="L456">            ? &quot;&quot;</span>
<span class="fc" id="L457">            : &quot;/__&quot; + url.getProtocol() + &quot;__&quot;;</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">    String domain = url.getAuthority() == null ? &quot;__domainless&quot; : url.getAuthority();</span>
<span class="fc" id="L459">    return domain + protocol + url.getFile();</span>
  }

  public static File url2file(URL url) {
<span class="nc" id="L463">    File f = null;</span>
    try {
<span class="nc" id="L465">      f = new File(url.toURI());</span>
<span class="nc" id="L466">    } catch (URISyntaxException e) {</span>
<span class="nc" id="L467">      f = new File(url.getPath());</span>
<span class="nc" id="L468">    }</span>
<span class="nc" id="L469">    return f;</span>
  }

  /**
   * For the given list, finds the index of the lowest value using the given comparator.
   *
   * @param values To compare
   * @param comparator To use
   * @return The index of the lowest value, or -1 if they are all null
   */
  static int lowestValueIndex(List&lt;String&gt; values, Comparator&lt;String&gt; comparator) {
<span class="fc" id="L480">    int index = 0;</span>
<span class="fc" id="L481">    String lowestValue = null;</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">    for (int i = 0; i &lt; values.size(); i++) {</span>
<span class="fc" id="L483">      String value = values.get(i);</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">      if (lowestValue == null) {</span>
<span class="fc" id="L485">        lowestValue = value;</span>
<span class="fc" id="L486">        index = i;</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">      } else if (comparator.compare(lowestValue, value) &gt; 0) {</span>
<span class="nc" id="L488">        lowestValue = value;</span>
<span class="nc" id="L489">        index = i;</span>
      }
    }

<span class="fc bfc" id="L493" title="All 2 branches covered.">    return lowestValue == null ? -1 : index;</span>
  }

  /**
   * For the given file's path, returns a proposed new filename (including path) with the extension
   * index and suffix. So a file of &quot;/tmp/input.txt&quot; -&gt; &quot;/tmp/input_part_10.txt&quot;.
   *
   * @param original File
   * @param index E.g. 10
   * @return The proposed name
   */
  private static File getChunkFile(File original, int index) {
<span class="fc" id="L505">    return new File(</span>
<span class="fc" id="L506">        original.getParentFile(),</span>
<span class="fc" id="L507">        FilenameUtils.getBaseName(original.getName())</span>
            + '_'
            + index
<span class="fc" id="L510">            + getFileExtension(original.getName()));</span>
  }

  private static boolean ignore(String line) {
<span class="nc bnc" id="L514" title="All 4 branches missed.">    return StringUtils.trimToNull(line) == null || line.startsWith(&quot;#&quot;);</span>
  }

  public int getLinesPerMemorySort() {
<span class="nc" id="L518">    return linesPerMemorySort;</span>
  }

  /**
   * Merges a list of intermediary sort chunk files into a single sorted file. On completion, the intermediary sort
   * chunk files are deleted.
   *
   * @param sortFiles sort chunk files to merge
   * @param sortedFileWriter writer to merge to. Can already be open and contain data
   * @param lineComparator To use when determining the order (reuse the one that was used to sort the individual
   *        files)
   */
  public void mergedSortedFiles(
      List&lt;File&gt; sortFiles, OutputStreamWriter sortedFileWriter, Comparator&lt;String&gt; lineComparator)
      throws IOException {
<span class="fc" id="L533">    List&lt;BufferedReader&gt; partReaders = new LinkedList&lt;&gt;();</span>
    try {
<span class="fc" id="L535">      List&lt;String&gt; partReaderLine = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">      for (File f : sortFiles) {</span>
        // Use UTF-8 sort order.
<span class="fc" id="L538">        partReaders.add(</span>
            new BufferedReader(
                new InputStreamReader(new FileInputStream(f), StandardCharsets.UTF_8)));
<span class="fc" id="L541">      }</span>
<span class="fc" id="L542">      boolean moreData = false;</span>
      // load first line in
<span class="fc bfc" id="L544" title="All 2 branches covered.">      for (BufferedReader partReader : partReaders) {</span>
<span class="fc" id="L545">        String partLine = partReader.readLine();</span>
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">        if (partLine != null) {</span>
<span class="fc" id="L547">          moreData = true;</span>
        }
        // we still add the &quot;null&quot; to keep the partReaders and partLineReader indexes in sync -
        // ALWAYS
<span class="fc" id="L551">        partReaderLine.add(partLine);</span>
<span class="fc" id="L552">      }</span>
      // keep going until all readers are exhausted
<span class="fc bfc" id="L554" title="All 2 branches covered.">      while (moreData) {</span>
<span class="fc" id="L555">        int index = lowestValueIndex(partReaderLine, lineComparator);</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">        if (index &gt;= 0) {</span>
<span class="fc" id="L557">          sortedFileWriter.write(partReaderLine.get(index));</span>
<span class="fc" id="L558">          sortedFileWriter.write(&quot;\n&quot;);</span>
<span class="fc" id="L559">          BufferedReader r = partReaders.get(index);</span>
<span class="fc" id="L560">          String partLine = r.readLine();</span>
          // TODO: Synchronization on local variable?
<span class="fc" id="L562">          synchronized (partReaderLine) {</span>
<span class="fc" id="L563">            partReaderLine.add(index, partLine);</span>
<span class="fc" id="L564">            partReaderLine.remove(index + 1);</span>
<span class="fc" id="L565">          }</span>
<span class="fc" id="L566">        } else {</span>
<span class="fc" id="L567">          moreData = false;</span>
        }
<span class="fc" id="L569">      }</span>
    } finally {
<span class="fc bfc" id="L571" title="All 2 branches covered.">      for (BufferedReader b : partReaders) {</span>
        try {
<span class="fc" id="L573">          b.close();</span>
<span class="nc" id="L574">        } catch (RuntimeException e) {</span>
<span class="fc" id="L575">        }</span>
<span class="fc" id="L576">      }</span>
      // I assume it periodically flushes anyway, so only need to do once at end...
<span class="fc" id="L578">      sortedFileWriter.flush();</span>
<span class="fc" id="L579">      sortedFileWriter.close();</span>
      // delete (intermediary) sort chunk files, only the sorted file remains
<span class="fc bfc" id="L581" title="All 2 branches covered.">      for (File f : sortFiles) {</span>
<span class="fc" id="L582">        f.delete();</span>
<span class="fc" id="L583">      }</span>
    }
<span class="fc" id="L585">  }</span>

  /**
   * Sorts the input file into the output file using the supplied delimited line parameters.
   *
   * This method is not reliable when the sort field may contain Unicode codepoints outside the Basic Multilingual Plane,
   * i.e. above \uFFFF. In that case, the sort order differs from Java's String sort order.  This should not be a problem
   * for most usage; the Supplementary Multilingual Planes contain ancient scripts, emojis, arrows and so on.
   *
   * @param input To sort
   * @param sorted The sorted version of the input excluding ignored header lines (see ignoreHeaderLines)
   * @param column the column that keeps the values to sort on
   * @param columnDelimiter the delimiter that separates columns in a row
   * @param enclosedBy optional column enclosing character, e.g. a double quote for CSVs
   * @param newlineDelimiter the chars used for new lines, usually \n, \n\r or \r
   * @param ignoreHeaderLines number of beginning lines to ignore, e.g. headers
   */
  public void sort(
      File input,
      File sorted,
      String encoding,
      int column,
      String columnDelimiter,
      Character enclosedBy,
      String newlineDelimiter,
      int ignoreHeaderLines)
      throws IOException {
    Comparator&lt;String&gt; lineComparator;
<span class="fc bfc" id="L613" title="All 2 branches covered.">    if (enclosedBy == null) {</span>
<span class="fc" id="L614">      lineComparator = new LineComparator(column, columnDelimiter);</span>
    } else {
<span class="fc" id="L616">      lineComparator = new LineComparator(column, columnDelimiter, enclosedBy);</span>
    }
<span class="fc" id="L618">    sort(</span>
        input,
        sorted,
        encoding,
        column,
        columnDelimiter,
        enclosedBy,
        newlineDelimiter,
        ignoreHeaderLines,
        lineComparator,
        false);
<span class="fc" id="L629">  }</span>

  /**
   * Sorts the input file into the output file using the supplied delimited line parameters.
   *
   * This method is not reliable when the sort field may contain Unicode codepoints outside the Basic Multilingual Plane,
   * i.e. above \uFFFF. In that case, the sort order differs from Java's String sort order.  This should not be a problem
   * for most usage; the Supplementary Multilingual Planes contain ancient scripts, emojis, arrows and so on.
   *
   * TODO: This method is globally synchronized, in case multiple sorts are attempted to the same file simultaneously.
   * This could be improved to allow synchronizing against the destination file, rather than for all sorts.
   *
   * @param input To sort
   * @param sorted The sorted version of the input excluding ignored header lines (see ignoreHeaderLines)
   * @param column the column that keeps the values to sort on
   * @param columnDelimiter the delimiter that separates columns in a row
   * @param enclosedBy optional column enclosing character, e.g. a double quote for CSVs
   * @param newlineDelimiter the chars used for new lines, usually \n, \r\n or \r
   * @param ignoreHeaderLines number of beginning lines to ignore, e.g. headers
   * @param lineComparator used to sort the output
   * @param ignoreCase ignore case order, this parameter couldn't have any effect if the LineComparator is used
   */
  public void sort(
      File input,
      File sorted,
      String encoding,
      int column,
      String columnDelimiter,
      Character enclosedBy,
      String newlineDelimiter,
      int ignoreHeaderLines,
      Comparator&lt;String&gt; lineComparator,
      boolean ignoreCase)
      throws IOException {
<span class="fc" id="L663">    LOG.debug(&quot;Sorting &quot; + input.getAbsolutePath() + &quot; as new file &quot; + sorted.getAbsolutePath());</span>
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">    if (encoding == null) {</span>
<span class="nc" id="L665">      LOG.warn(&quot;No encoding specified, assume UTF-8&quot;);</span>
<span class="nc" id="L666">      encoding = FileUtils.UTF8;</span>
    }
<span class="fc" id="L668">    synchronized (sortLock) {</span>
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">      if (sorted.exists()) {</span>
        // Delete a file, which will allow processes with it open to continue reading it.
        // The GNU sort truncates and appends, which would mean a partial read otherwise.
<span class="fc" id="L672">        LOG.warn(&quot;Deleting existed sorted file {}&quot;, sorted.getAbsoluteFile());</span>
<span class="fc" id="L673">        sorted.delete();</span>
      }
      // if the id is in the first column, first try sorting via shell as its the fastest we can get
<span class="fc bfc" id="L676" title="All 2 branches covered.">      if (!sortInGnu(</span>
          input,
          sorted,
          encoding,
          ignoreHeaderLines,
          column,
          columnDelimiter,
          newlineDelimiter,
          ignoreCase)) {
<span class="fc" id="L685">        LOG.debug(&quot;No GNU sort available, using native Java sorting&quot;);</span>
<span class="fc" id="L686">        sortInJava(input, sorted, encoding, lineComparator, ignoreHeaderLines);</span>
      }
<span class="fc" id="L688">    }</span>
<span class="fc" id="L689">  }</span>

  /**
   * Sorts the input file into the output file using the supplied lineComparator.
   *
   * @param input To sort
   * @param sorted The sorted version of the input excluding ignored header lines (see ignoreHeaderLines)
   * @param lineComparator To use during comparison
   * @param ignoreHeaderLines number of beginning lines to ignore, e.g. headers
   */
  public void sortInJava(
      File input,
      File sorted,
      String encoding,
      Comparator&lt;String&gt; lineComparator,
      int ignoreHeaderLines)
      throws IOException {
<span class="fc" id="L706">    LOG.debug(&quot;Sorting File[&quot; + input.getAbsolutePath() + ']');</span>
<span class="fc" id="L707">    long start = System.currentTimeMillis();</span>
<span class="fc" id="L708">    List&lt;File&gt; sortFiles = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L709">    BufferedReader br =</span>
        new BufferedReader(new InputStreamReader(new FileInputStream(input), encoding));
<span class="fc" id="L711">    List&lt;String&gt; headerLines = new LinkedList&lt;&gt;();</span>
    try {
<span class="fc" id="L713">      String line = br.readLine();</span>
<span class="fc" id="L714">      int fileCount = 0;</span>

<span class="fc" id="L716">      List&lt;String&gt; linesToSort = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">      while (line != null) {</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">        if (ignoreHeaderLines &gt; 0) {</span>
<span class="fc" id="L719">          headerLines.add(line);</span>
<span class="fc" id="L720">          ignoreHeaderLines--;</span>
        } else {
<span class="fc" id="L722">          linesToSort.add(line);</span>

          // if buffer is full, then sort and write to file
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">          if (linesToSort.size() == linesPerMemorySort) {</span>
<span class="nc" id="L726">            sortFiles.add(sortAndWrite(input, encoding, lineComparator, fileCount, linesToSort));</span>
<span class="nc" id="L727">            linesToSort = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L728">            fileCount++;</span>
          }
        }
<span class="fc" id="L731">        line = br.readLine();</span>
      }
      // catch the last lot
<span class="pc bpc" id="L734" title="1 of 2 branches missed.">      if (!linesToSort.isEmpty()) {</span>
<span class="fc" id="L735">        sortFiles.add(sortAndWrite(input, encoding, lineComparator, fileCount, linesToSort));</span>
      }
    } finally {
<span class="fc" id="L738">      br.close();</span>
    }
<span class="fc" id="L740">    LOG.debug(</span>
<span class="fc" id="L741">        sortFiles.size()</span>
            + &quot; sorted file chunks created in &quot;
<span class="fc" id="L743">            + (System.currentTimeMillis() - start) / 1000</span>
            + &quot; secs&quot;);

    // now merge the sorted files into one single sorted file
<span class="fc" id="L747">    FileWriter sortedFileWriter = new FileWriter(sorted);</span>
    // first write the old header lines if existing
<span class="fc bfc" id="L749" title="All 2 branches covered.">    for (String h : headerLines) {</span>
<span class="fc" id="L750">      sortedFileWriter.write(h);</span>
<span class="fc" id="L751">      sortedFileWriter.write(&quot;\n&quot;);</span>
<span class="fc" id="L752">    }</span>
<span class="fc" id="L753">    mergedSortedFiles(sortFiles, sortedFileWriter, lineComparator);</span>

<span class="fc" id="L755">    LOG.debug(</span>
        &quot;File &quot;
<span class="fc" id="L757">            + input.getAbsolutePath()</span>
            + &quot; sorted successfully using &quot;
<span class="fc" id="L759">            + sortFiles.size()</span>
            + &quot; parts to do sorting in &quot;
<span class="fc" id="L761">            + (System.currentTimeMillis() - start) / 1000</span>
            + &quot; secs&quot;);
<span class="fc" id="L763">  }</span>

  /**
   * Splits the supplied file into files of set line size and with a suffix.
   *
   * @param input To split up
   * @param linesPerOutput Lines per split file
   * @param extension The file extension to use - e.g. &quot;.txt&quot;
   * @return The split files
   */
  public List&lt;File&gt; split(File input, int linesPerOutput, String extension) throws IOException {
<span class="nc" id="L774">    LOG.debug(&quot;Splitting File[&quot; + input.getAbsolutePath() + ']');</span>
<span class="nc" id="L775">    long timer = System.currentTimeMillis();</span>
<span class="nc" id="L776">    List&lt;File&gt; splitFiles = new LinkedList&lt;&gt;();</span>
    // Use ISO-8859-1 as a binary-safe encoding.
<span class="nc" id="L778">    BufferedReader br =</span>
        new BufferedReader(
            new InputStreamReader(new FileInputStream(input), StandardCharsets.ISO_8859_1));
<span class="nc" id="L781">    String line = br.readLine();</span>
<span class="nc" id="L782">    int fileCount = 0;</span>
<span class="nc" id="L783">    File splitFile = getChunkFile(input, fileCount);</span>
<span class="nc" id="L784">    fileCount++;</span>
<span class="nc" id="L785">    splitFiles.add(splitFile);</span>
<span class="nc" id="L786">    OutputStreamWriter fw =</span>
        new OutputStreamWriter(new FileOutputStream(splitFile), StandardCharsets.ISO_8859_1);
    try {
<span class="nc" id="L789">      int lineCount = 0;</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">      while (line != null) {</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">        if (lineCount == linesPerOutput) {</span>
<span class="nc" id="L792">          fw.flush();</span>
<span class="nc" id="L793">          fw.close();</span>
<span class="nc" id="L794">          splitFile = getChunkFile(input, fileCount);</span>
<span class="nc" id="L795">          splitFiles.add(splitFile);</span>
          // is ok to reuse, as last one is closed, and this will always get closed - see finally
          // below
<span class="nc" id="L798">          fw = new OutputStreamWriter(new FileOutputStream(splitFile), StandardCharsets.ISO_8859_1);</span>
<span class="nc" id="L799">          fileCount++;</span>
<span class="nc" id="L800">          lineCount = 0;</span>
        }
<span class="nc" id="L802">        fw.write(line);</span>
<span class="nc" id="L803">        fw.write(&quot;\n&quot;);</span>
<span class="nc" id="L804">        line = br.readLine();</span>
<span class="nc" id="L805">        lineCount++;</span>
      }
<span class="nc" id="L807">      fw.flush();</span>
    } finally {
<span class="nc" id="L809">      fw.close();</span>
    }
<span class="nc" id="L811">    LOG.debug(</span>
        &quot;File[&quot;
<span class="nc" id="L813">            + input.getAbsolutePath()</span>
            + &quot;] split successfully into[&quot;
<span class="nc" id="L815">            + splitFiles.size()</span>
            + &quot;] parts in secs[&quot;
<span class="nc" id="L817">            + (1 + System.currentTimeMillis() - timer) / 1000</span>
            + &quot;]&quot;);
<span class="nc" id="L819">    return splitFiles;</span>
  }

  /**
   * Test whether we have a new enough version of GNU Sort that supports (primarily) the -k option with a start and end
   * column.
   *
   * Mac OS only includes an old version of GNU sort, and will fail this test.
   */
  private boolean gnuSortAvailable() {
<span class="fc bfc" id="L829" title="All 2 branches covered.">    if (gnuSortAvailable != null) {</span>
<span class="fc" id="L830">      return gnuSortAvailable;</span>
    }

    try {
<span class="fc" id="L834">      String command = &quot;sort -k1,1 -t',' --ignore-case /dev/null&quot;;</span>
<span class="fc" id="L835">      LOG.debug(&quot;Testing capability of GNU sort with command: {}&quot;, command);</span>

<span class="fc" id="L837">      Process process = new ProcessBuilder(&quot;/bin/sh&quot;, &quot;-c&quot;, command).start();</span>
<span class="fc" id="L838">      int exitValue = process.waitFor();</span>

<span class="pc bpc" id="L840" title="1 of 2 branches missed.">      if (exitValue == 0) {</span>
<span class="fc" id="L841">        LOG.debug(&quot;GNU sort is capable&quot;);</span>
<span class="fc" id="L842">        gnuSortAvailable = true;</span>
      } else {
<span class="nc" id="L844">        LOG.warn(</span>
            &quot;GNU sort does not exist or is too old, and will not be used.  Sorting large files will be slow.&quot;,
<span class="nc" id="L846">            new InputStreamUtils().readEntireStream(process.getErrorStream()).replace('\n', ' '));</span>
<span class="nc" id="L847">        gnuSortAvailable = false;</span>
      }
<span class="nc" id="L849">    } catch (Exception e) {</span>
<span class="nc" id="L850">      LOG.warn(</span>
          &quot;GNU sort does not exist or is too old, and will not be used.  Sorting large files will be slow.&quot;,
          e);
<span class="nc" id="L853">      gnuSortAvailable = false;</span>
<span class="fc" id="L854">    }</span>

<span class="fc" id="L856">    return gnuSortAvailable;</span>
  }

  /**
   * sort a text file via an external GNU sort command:
   * sorting tabs at 3rd column, numerical reverse order
   * sort -t$'\t' -k3 -o sorted.txt col2007.txt
   * &lt;p/&gt;
   * The GNU sort based sorting is extremely efficient and much, much faster than the current sortInJava method. It is
   * locale aware though and we only want the native C sorting locale. See
   * http://www.gnu.org/software/coreutils/faq/coreutils-faq.html#Sort-does-not-sort-in-normal-order_0021
   * &lt;p/&gt;
   * Example C sort order:
   * &lt;p/&gt;
   * &lt;pre&gt;
   * 1 oOdontoceti
   * 10 gGlobicephala melaena melaena Traill
   * 100 gGlobicephala melaena melaena Traill
   * 101 gGlobicephala melaena melaena Traill
   * 11 pPontoporia Gray
   * 12 pPontoporia blainvillei Gervais and d'Orbigny
   * 120 iInia d'Orbigny
   * 121 iInia geoffrensis Blainville
   * 2 sSusuidae
   * 20 cCetacea
   * Amphiptera
   * Amphiptera pacifica Giglioli
   * Anarnak Lacépède
   * Balaena mangidach Chamisso
   * amphiptera
   * amphiptera pacifica Giglioli
   * anarnak Lacépède
   * balaena mangidach Chamisso
   * &lt;/pre&gt;
   */
  protected boolean sortInGnu(
      File input,
      File sorted,
      String encoding,
      int ignoreHeaderLines,
      int column,
      String columnDelimiter,
      String lineDelimiter,
      boolean ignoreCase)
      throws IOException {
    String command;
    // GNU sort is checked for use when:
    // • line delimiter is \n
    // • column delimiter is set and we're not using the first column
    // • sort version is sufficient to include start and end column (-k 1,1).
    // Use the --debug option to sort if working on this code.
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">    if (lineDelimiter == null</span>
<span class="pc bpc" id="L908" title="1 of 6 branches missed.">        || !lineDelimiter.contains(&quot;\n&quot;)</span>
        || (columnDelimiter != null &amp;&amp; column &gt; 0)
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">        || !gnuSortAvailable()) {</span>
<span class="fc" id="L911">      LOG.debug(&quot;Cannot use GNU sort on this file&quot;);</span>
<span class="fc" id="L912">      return false;</span>
    }

    // keep header rows
<span class="fc" id="L916">    boolean success = false;</span>
    try {
<span class="fc" id="L918">      LinkedList&lt;String&gt; cmds = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L919">      cmds.add(&quot;/bin/sh&quot;);</span>
<span class="fc" id="L920">      cmds.add(&quot;-c&quot;);</span>
<span class="fc" id="L921">      cmds.add(&quot;&quot;);</span>
<span class="fc" id="L922">      ProcessBuilder pb = new ProcessBuilder(cmds);</span>
<span class="fc" id="L923">      Map&lt;String, String&gt; env = pb.environment();</span>

      // clear the environment, but keep specified temp working directory
<span class="pc bpc" id="L926" title="1 of 2 branches missed.">      env.keySet().removeIf(key -&gt; !(key.equals(&quot;TMPDIR&quot;)));</span>
<span class="pc bpc" id="L927" title="1 of 2 branches missed.">      if (System.getProperty(&quot;java.io.tmpdir&quot;) != null) {</span>
<span class="fc" id="L928">        env.put(&quot;TMPDIR&quot;, System.getProperty(&quot;java.io.tmpdir&quot;));</span>
      }
      // make sure we use the C locale for sorting
<span class="fc" id="L931">      env.put(&quot;LC_ALL&quot;, &quot;C&quot;);</span>

<span class="fc" id="L933">      String sortArgs =</span>
<span class="fc" id="L934">          String.format(</span>
              &quot; %s -k%d,%d -t'%s'&quot;,
<span class="pc bpc" id="L936" title="1 of 2 branches missed.">              ignoreCase ? &quot;--ignore-case&quot; : &quot;&quot;, column + 1, column + 1, columnDelimiter);</span>

<span class="fc bfc" id="L938" title="All 2 branches covered.">      if (ignoreHeaderLines &gt; 0) {</span>
        // copy header lines
<span class="fc" id="L940">        command =</span>
            &quot;head -n &quot;
                + ignoreHeaderLines
                + ' '
<span class="fc" id="L944">                + input.getAbsolutePath()</span>
                + &quot; &gt; &quot;
<span class="fc" id="L946">                + sorted.getAbsolutePath();</span>
<span class="fc" id="L947">        LOG.debug(&quot;Issue external command: {}&quot;, command);</span>
<span class="fc" id="L948">        cmds.removeLast();</span>
<span class="fc" id="L949">        cmds.add(command);</span>
<span class="fc" id="L950">        Process process = pb.start();</span>
<span class="fc" id="L951">        int exitValue = process.waitFor();</span>
<span class="pc bpc" id="L952" title="1 of 2 branches missed.">        if (exitValue != 0) {</span>
<span class="nc" id="L953">          LOG.warn(&quot;Error sorting file (copying header lines) with GNU head&quot;);</span>
<span class="nc" id="L954">          return false;</span>
        }

        // do the sorting ignoring the header rows
<span class="fc" id="L958">        command =</span>
            &quot;sed &quot;
                + ignoreHeaderLines
                + &quot;d &quot;
<span class="fc" id="L962">                + input.getAbsolutePath()</span>
                + &quot; | &quot;
                + &quot;sort &quot;
                + sortArgs
                + &quot; &gt;&gt; &quot;
<span class="fc" id="L967">                + sorted.getAbsolutePath();</span>
<span class="fc" id="L968">      } else {</span>
        // do sorting directly, we don't have header rows
<span class="fc" id="L970">        command =</span>
<span class="fc" id="L971">            &quot;sort &quot; + sortArgs + &quot; -o &quot; + sorted.getAbsolutePath() + ' ' + input.getAbsolutePath();</span>
      }

<span class="fc" id="L974">      LOG.debug(&quot;Issue external command: {}&quot;, command);</span>
<span class="fc" id="L975">      cmds.removeLast();</span>
<span class="fc" id="L976">      cmds.add(command);</span>
<span class="fc" id="L977">      Process process = pb.start();</span>
      // get the stdout and stderr from the command that was run
<span class="fc" id="L979">      InputStream err = process.getErrorStream();</span>
<span class="fc" id="L980">      int exitValue = process.waitFor();</span>
<span class="fc bfc" id="L981" title="All 2 branches covered.">      if (exitValue == 0) {</span>
<span class="fc" id="L982">        LOG.debug(&quot;Successfully sorted file with GNU sort&quot;);</span>
<span class="fc" id="L983">        success = true;</span>
      } else {
<span class="fc" id="L985">        LOG.warn(&quot;Error sorting file with GNU sort&quot;);</span>
<span class="fc" id="L986">        InputStreamUtils isu = new InputStreamUtils();</span>
<span class="fc" id="L987">        System.err.append(isu.readEntireStream(err));</span>
      }
<span class="nc" id="L989">    } catch (Exception e) {</span>
<span class="nc" id="L990">      LOG.warn(&quot;Caught Exception using GNU sort&quot;, e);</span>
<span class="fc" id="L991">    }</span>
<span class="fc" id="L992">    return success;</span>
  }

  /**
   * Sorts the lines and writes to file using the
   *
   * @param input File to base the name on
   * @param lineComparator To compare the lines for sorting
   * @param fileCount Used for the file name
   * @param linesToSort To actually sort
   * @return The written file
   */
  private File sortAndWrite(
      File input,
      String encoding,
      Comparator&lt;String&gt; lineComparator,
      int fileCount,
      List&lt;String&gt; linesToSort)
      throws IOException {
<span class="fc" id="L1011">    long start = System.currentTimeMillis();</span>
<span class="fc" id="L1012">    linesToSort.sort(lineComparator);</span>
    // When implementing a comparator, make it SUPER quick!!!
<span class="fc" id="L1014">    LOG.debug(</span>
        &quot;Collections.sort took msec[&quot;
<span class="fc" id="L1016">            + (System.currentTimeMillis() - start)</span>
            + &quot;] to sort records[&quot;
<span class="fc" id="L1018">            + linesToSort.size()</span>
            + ']');
<span class="fc" id="L1020">    File sortFile = getChunkFile(input, fileCount);</span>
<span class="fc" id="L1021">    try (Writer fw = new OutputStreamWriter(new FileOutputStream(sortFile), encoding)) {</span>
<span class="fc bfc" id="L1022" title="All 2 branches covered.">      for (String s : linesToSort) {</span>
<span class="fc" id="L1023">        fw.write(s);</span>
<span class="fc" id="L1024">        fw.write(&quot;\n&quot;);</span>
<span class="fc" id="L1025">      }</span>
    }
<span class="fc" id="L1027">    return sortFile;</span>
  }

  /**
   * Creates an empty file or updates the last updated timestamp on the same as the unix command of
   * the same name.
   *
   * &lt;p&gt;From Guava.
   *
   * @param file the file to create or update
   * @throws IOException if an I/O error occurs
   */
  public static void touch(File file) throws IOException {
<span class="nc" id="L1040">    Objects.requireNonNull(file);</span>
<span class="nc bnc" id="L1041" title="All 4 branches missed.">    if (!file.createNewFile() &amp;&amp; !file.setLastModified(System.currentTimeMillis())) {</span>
<span class="nc" id="L1042">      throw new IOException(&quot;Unable to update modification time of &quot; + file);</span>
    }
<span class="nc" id="L1044">  }</span>

  /**
   * Returns the &lt;a href=&quot;http://en.wikipedia.org/wiki/Filename_extension&quot;&gt;file extension&lt;/a&gt; for
   * the given file name, or the empty string if the file has no extension. The result does not
   * include the '{@code .}'.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This method simply returns everything after the last '{@code .}' in the file's
   * name as determined by {@link File#getName}. It does not account for any filesystem-specific
   * behavior that the {@link File} API does not already account for. For example, on NTFS it will
   * report {@code &quot;txt&quot;} as the extension for the filename {@code &quot;foo.exe:.txt&quot;} even though NTFS
   * will drop the {@code &quot;:.txt&quot;} part of the name when the file is actually created on the
   * filesystem due to NTFS's &lt;a href=&quot;https://goo.gl/vTpJi4&quot;&gt;Alternate Data Streams&lt;/a&gt;.
   *
   * &lt;p&gt;From Guava.
   */
  public static String getFileExtension(String fullName) {
<span class="fc" id="L1061">    Objects.requireNonNull(fullName);</span>
<span class="fc" id="L1062">    String fileName = new File(fullName).getName();</span>
<span class="fc" id="L1063">    int dotIndex = fileName.lastIndexOf('.');</span>
<span class="pc bpc" id="L1064" title="1 of 2 branches missed.">    return (dotIndex == -1) ? &quot;&quot; : fileName.substring(dotIndex + 1);</span>
  }

  /**
   * Creates any necessary but nonexistent parent directories of the specified file. Note that if
   * this operation fails it may have succeeded in creating some (but not all) of the necessary
   * parent directories.
   *
   * &lt;p&gt;From Guava.
   *
   * @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent
   *     directories of the specified file could not be created.
   */
  public static void createParentDirs(File file) throws IOException {
<span class="fc" id="L1078">    Objects.requireNonNull(file);</span>
<span class="fc" id="L1079">    File parent = file.getCanonicalFile().getParentFile();</span>
<span class="pc bpc" id="L1080" title="1 of 2 branches missed.">    if (parent == null) {</span>
      /*
       * The given directory is a filesystem root. All zero of its ancestors exist. This doesn't
       * mean that the root itself exists -- consider x:\ on a Windows machine without such a drive
       * -- or even that the caller can create it, but this method makes no such guarantees even for
       * non-root files.
       */
<span class="nc" id="L1087">      return;</span>
    }
    //noinspection ResultOfMethodCallIgnored
<span class="fc" id="L1090">    parent.mkdirs();</span>
<span class="pc bpc" id="L1091" title="1 of 2 branches missed.">    if (!parent.isDirectory()) {</span>
<span class="nc" id="L1092">      throw new IOException(&quot;Unable to create parent directories of &quot; + file);</span>
    }
<span class="fc" id="L1094">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>