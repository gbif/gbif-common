<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PropertiesUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GBIF Common</a> &gt; <a href="index.source.html" class="el_package">org.gbif.utils.file.properties</a> &gt; <span class="el_source">PropertiesUtil.java</span></div><h1>PropertiesUtil.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2021 Global Biodiversity Information Facility (GBIF)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gbif.utils.file.properties;

import org.gbif.utils.PreconditionUtils;
import org.gbif.utils.file.FileUtils;
import org.gbif.utils.file.ResourcesUtil;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.util.Iterator;
import java.util.Objects;
import java.util.Properties;

import org.apache.commons.lang3.BooleanUtils;
import org.apache.commons.lang3.StringUtils;

/**
 * Utility class for handling properties files.
 * TODO this class should probably be in a &quot;properties&quot; package at the same level as &quot;file&quot;
 */
public final class PropertiesUtil {

  /**
   * When we encode strings, we always specify UTF8 encoding
   */
<span class="fc" id="L45">  public static final String UTF8_ENCODING = FileUtils.UTF8;</span>

  /**
   * Private default constructor.
   */
  private PropertiesUtil() {
    // empty block
  }

  /**
   * Loads a properties file.
   * The file should be available in the classpath, the default {@link ClassLoader} is used to load the file.
   *
   * @throws IOException Should there be an issue in loading the file
   * @throws IllegalArgumentException If the file does not exist
   */
  public static Properties loadProperties(String propertiesFile) throws IOException, IllegalArgumentException {
<span class="nc" id="L62">    Properties tempProperties = new Properties();</span>
<span class="nc" id="L63">    File file = new File(propertiesFile);</span>

<span class="nc bnc" id="L65" title="All 2 branches missed.">    if (file.exists()) { // first tries to load the file as a external file</span>
<span class="nc" id="L66">      try (InputStream is = new FileInputStream(file)) {</span>
<span class="nc" id="L67">        tempProperties.load(is);</span>
<span class="nc" id="L68">      }</span>
    } else { // tries to load the file as a resource
<span class="nc" id="L70">      URL configFileURL = ResourcesUtil.getResource(propertiesFile);</span>
<span class="nc" id="L71">      try (InputStream is = configFileURL.openStream()) {</span>
<span class="nc" id="L72">        tempProperties.load(is);</span>
      }
    }

<span class="nc" id="L76">    return tempProperties;</span>
  }

  /**
   * Reads a property file from an absolute filepath.
   */
  public static Properties readFromFile(String filepath) throws IOException, IllegalArgumentException {
<span class="nc" id="L83">    PreconditionUtils.checkArgument(StringUtils.isNotBlank(filepath), &quot;No properties file given&quot;);</span>
<span class="nc" id="L84">    File pf = new File(filepath);</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">    if (!pf.exists()) {</span>
<span class="nc" id="L86">      throw new IllegalArgumentException(&quot;Cannot find properties file &quot; + filepath);</span>
    }
<span class="nc" id="L88">    Properties properties = new Properties();</span>

<span class="nc" id="L90">    try (FileReader reader = new FileReader(pf)) {</span>
<span class="nc" id="L91">      properties.load(reader);</span>
    }
<span class="nc" id="L93">    return properties;</span>
  }

  /**
   * Reads and casts the named property as an Double.
   *
   * @param p The properties file to read from.
   * @param key To read the value of.
   * @param exceptionForNull If true, and the property is not found an IAE is thrown, otherwise defaultValue is
   *        returned
   * @param defaultValue If the property is not found, and exceptionForNull is false, this is returned for missing
   *        properties.
   * @return The property at the key as an Double
   * @throws IllegalArgumentException if the property is invalid (can't be cast to a double) or not found and we are
   *         instructed to throw it.
   */
  public static Double propertyAsDouble(Properties p, String key, boolean exceptionForNull, Double defaultValue)
    throws IllegalArgumentException {
<span class="nc" id="L111">    String v = p.getProperty(key);</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">    if (v != null) {</span>
      try {
<span class="nc" id="L114">        return Double.parseDouble(v);</span>
<span class="nc" id="L115">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L116">        throw new IllegalArgumentException(&quot;Invalid value[&quot; + v + &quot;] supplied for &quot; + key);</span>
      }
    } else {
<span class="nc bnc" id="L119" title="All 2 branches missed.">      if (exceptionForNull) {</span>
<span class="nc" id="L120">        throw new IllegalArgumentException(&quot;Missing property for &quot; + key);</span>
      } else {
<span class="nc" id="L122">        return defaultValue;</span>
      }
    }
  }

  /**
   * Reads and casts the named property as an Float.
   *
   * @param p The properties file to read from.
   * @param key To read the value of.
   * @param exceptionForNull If true, and the property is not found an IAE is thrown, otherwise defaultValue is
   *        returned
   * @param defaultValue If the property is not found, and exceptionForNull is false, this is returned for missing
   *        properties.
   * @return The property at the key as an Float
   * @throws IllegalArgumentException if the property is invalid (can't be cast to a float) or not found and we are
   *         instructed to throw it.
   */
  public static Float propertyAsFloat(Properties p, String key, boolean exceptionForNull, Float defaultValue)
    throws IllegalArgumentException {
<span class="nc" id="L142">    String v = p.getProperty(key);</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">    if (v != null) {</span>
      try {
<span class="nc" id="L145">        return Float.parseFloat(v);</span>
<span class="nc" id="L146">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L147">        throw new IllegalArgumentException(&quot;Invalid value[&quot; + v + &quot;] supplied for &quot; + key);</span>
      }
    } else {
<span class="nc bnc" id="L150" title="All 2 branches missed.">      if (exceptionForNull) {</span>
<span class="nc" id="L151">        throw new IllegalArgumentException(&quot;Missing property for &quot; + key);</span>
      } else {
<span class="nc" id="L153">        return defaultValue;</span>
      }
    }
  }

  /**
   * Reads and casts the named property as an Integer.
   *
   * @param p The properties file to read from.
   * @param key To read the value of.
   * @param exceptionForNull If true, and the property is not found an IAE is thrown, otherwise defaultValue is
   *        returned
   * @param defaultValue If the property is not found, and exceptionForNull is false, this is returned for missing
   *        properties.
   * @return The property at the key as an int
   * @throws IllegalArgumentException if the property is invalid (can't be cast to an int) or not found and we are
   *         instructed to throw it.
   */
  public static Integer propertyAsInt(Properties p, String key, boolean exceptionForNull, Integer defaultValue)
    throws IllegalArgumentException {
<span class="nc" id="L173">    String v = p.getProperty(key);</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">    if (v != null) {</span>
      try {
<span class="nc" id="L176">        return Integer.parseInt(v);</span>
<span class="nc" id="L177">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L178">        throw new IllegalArgumentException(&quot;Invalid value[&quot; + v + &quot;] supplied for &quot; + key);</span>
      }
    } else {
<span class="nc bnc" id="L181" title="All 2 branches missed.">      if (exceptionForNull) {</span>
<span class="nc" id="L182">        throw new IllegalArgumentException(&quot;Missing property for &quot; + key);</span>
      } else {
<span class="nc" id="L184">        return defaultValue;</span>
      }
    }
  }

  /**
   * Reads and casts the named property as a boolean.
   * Case insensitive values for 'true', 'on', 'yes', 't' and 'y' return true values,
   * 'false', 'off', 'no', 'f' and 'n' return false.
   * Otherwise or in case of a missing property the default will be used.
   *
   * @param p The properties file to read from.
   * @param key To read the value of.
   * @param defaultValue If the property is not found this is returned for missing properties.
   * @return The property at the key as a boolean
   */
  public static boolean propertyAsBool(Properties p, String key, boolean defaultValue) {
<span class="fc" id="L201">    Boolean val = BooleanUtils.toBooleanObject(p.getProperty(key, null));</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">    return val == null ? defaultValue : val;</span>
  }

  /**
   * Reads and converts the named property as UTF8 bytes.
   *
   * @param p The properties file to read from.
   * @param key To read the value of.
   * @param exceptionForNull If true, and the property is not found an IAE is thrown, otherwise defaultValue is
   *        returned
   * @param defaultValue If the property is not found, and exceptionForNull is false, this is returned for missing
   *        properties.
   * @return The property at the key as byte[]t
   * @throws IllegalArgumentException if the property is not found and we are instructed to throw it.
   */
  public static byte[] propertyAsUTF8Bytes(Properties p, String key, boolean exceptionForNull, byte[] defaultValue)
    throws IllegalArgumentException {
<span class="nc" id="L219">    String v = p.getProperty(key);</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">    if (v != null) {</span>
      try {
<span class="nc" id="L222">        return v.getBytes(UTF8_ENCODING);</span>
<span class="nc" id="L223">      } catch (UnsupportedEncodingException e) {</span>
        // never one would hope
<span class="nc" id="L225">        throw new RuntimeException(&quot;System does not support &quot; + UTF8_ENCODING + &quot; encoding&quot;);</span>
      }
    } else {
<span class="nc bnc" id="L228" title="All 2 branches missed.">      if (exceptionForNull) {</span>
<span class="nc" id="L229">        throw new IllegalArgumentException(&quot;Missing property for &quot; + key);</span>
      } else {
<span class="nc" id="L231">        return defaultValue;</span>
      }
    }
  }

  /**
   * Filters and translates Properties with a prefix.
   * The resulting Properties will only include the properties that start with the provided prefix with that prefix
   * removed (e.g. myprefix.key1 will be returned as key1 if prefix = &quot;myprefix.&quot;)
   *
   * @param properties to filter and translate
   * @param prefix prefix used to filter the properties. (e.g. &quot;myprefix.&quot;)
   * @return new Properties object with filtered and translated properties. Never null.
   */
  public static Properties filterProperties(final Properties properties, String prefix) {
<span class="fc" id="L246">    Objects.requireNonNull(properties, &quot;Can't filter a null Properties&quot;);</span>
<span class="fc" id="L247">    PreconditionUtils.checkState(StringUtils.isNotBlank(prefix),</span>
        &quot;Can't filter using a blank prefix [&quot; + properties + &quot;]&quot;);

<span class="fc" id="L250">    Properties filtered = new Properties();</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">    for (String key : properties.stringPropertyNames()) {</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">      if (key.startsWith(prefix)) {</span>
<span class="fc" id="L253">        filtered.setProperty(key.substring(prefix.length()), properties.getProperty(key));</span>
      }
<span class="fc" id="L255">    }</span>
<span class="fc" id="L256">    return filtered;</span>
  }

  /**
   * Returns a new Properties object that contains only the elements where the key starts by the provided
   * prefix. The same keys will be used in the returned Properties.
   * @param original
   * @param prefix
   * @return
   */
  public static Properties subsetProperties(final Properties original, String prefix) {
<span class="fc" id="L267">    return propertiesByPrefix(original, prefix, false);</span>
  }

  /**
   * Remove properties from the original object and return the removed element(s) as new Properties object.
   * The same keys will be used in the returned Properties.
   * @param original original object in which the element will be removed if key starts with provided prefix.
   * @param prefix
   * @return
   */
  public static Properties removeProperties(final Properties original, String prefix) {
<span class="fc" id="L278">    return propertiesByPrefix(original, prefix, true);</span>
  }

  /**
   * Get a a new Properties object that only contains the elements that start with the prefix.
   * The same keys will be used in the returned Properties.
   * @param original
   * @param prefix
   * @param remove should the element(s) be removed from the original Properties object
   * @return
   */
  private static Properties propertiesByPrefix(final Properties original, String prefix, boolean remove) {
<span class="fc" id="L290">    Objects.requireNonNull(original, &quot;Can't filter a null Properties&quot;);</span>
<span class="fc" id="L291">    PreconditionUtils.checkState(StringUtils.isNotBlank(prefix), &quot;Can't filter using a blank prefix [&quot; + original + &quot;]&quot;);</span>

<span class="fc" id="L293">    Properties filtered = new Properties();</span>

<span class="fc bfc" id="L295" title="All 2 branches covered.">    if(original.isEmpty()){</span>
<span class="fc" id="L296">      return filtered;</span>
    }

<span class="fc" id="L299">    Iterator&lt;Object&gt; keysIt = original.keySet().iterator();</span>
    String key;
<span class="fc bfc" id="L301" title="All 2 branches covered.">    while (keysIt.hasNext()) {</span>
<span class="fc" id="L302">      key = String.valueOf(keysIt.next());</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">      if (key.startsWith(prefix)) {</span>
<span class="fc" id="L304">        filtered.setProperty(key, original.getProperty(key));</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">        if(remove){</span>
<span class="fc" id="L306">          keysIt.remove();</span>
        }
      }
    }
<span class="fc" id="L310">    return filtered;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>