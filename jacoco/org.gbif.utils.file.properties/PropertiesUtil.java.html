<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PropertiesUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GBIF Common</a> &gt; <a href="index.source.html" class="el_package">org.gbif.utils.file.properties</a> &gt; <span class="el_source">PropertiesUtil.java</span></div><h1>PropertiesUtil.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2015 Global Biodiversity Information Facility (GBIF)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gbif.utils.file.properties;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.util.Iterator;
import java.util.Properties;

import com.google.common.base.Preconditions;
import com.google.common.base.Strings;
import com.google.common.io.Closer;
import com.google.common.io.Resources;
import org.apache.commons.lang3.BooleanUtils;
import org.apache.commons.lang3.StringUtils;
import org.gbif.utils.file.FileUtils;

/**
 * Utility class for handling properties files.
 * TODO this class should probably be in a &quot;properties&quot; package at the same level as &quot;file&quot;
 */
public class PropertiesUtil {

  /**
   * When we encode strings, we always specify UTF8 encoding
   */
<span class="fc" id="L44">  public static final String UTF8_ENCODING = FileUtils.UTF8;</span>

  /**
   * Private default constructor.
   */
  private PropertiesUtil() {
    // empty block
  }

  /**
   * Loads a properties file.
   * The file should be available in the classpath, the default {@link ClassLoader} is used to load the file.
   *
   * @throws IOException Should there be an issue in loading the file
   * @throws IllegalArgumentException If the file does not exist
   */
  public static Properties loadProperties(String propertiesFile) throws IOException, IllegalArgumentException {
<span class="nc" id="L61">    Properties tempProperties = new Properties();</span>
<span class="nc" id="L62">    Closer closer = Closer.create();</span>
    try {
<span class="nc" id="L64">      File file = new File(propertiesFile);</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">      if (file.exists()) {// first tries to load the file as a external file</span>
<span class="nc" id="L66">        tempProperties.load(closer.register(new FileInputStream(file)));</span>
      } else { // tries to load the file as a resource
<span class="nc" id="L68">        URL configFileURL = Resources.getResource(propertiesFile);</span>
<span class="nc" id="L69">        tempProperties.load(closer.register(Resources.asByteSource(configFileURL).openStream()));</span>
      }
    } finally {
<span class="nc" id="L72">      closer.close();</span>
    }
<span class="nc" id="L74">    return tempProperties;</span>
  }

  /**
   * Reads a property file from an absolute filepath.
   */
  public static Properties readFromFile(String filepath) throws IOException, IllegalArgumentException {
<span class="nc bnc" id="L81" title="All 2 branches missed.">    if (Strings.isNullOrEmpty(filepath)) {</span>
<span class="nc" id="L82">      throw new IllegalArgumentException(&quot;No properties file given&quot;);</span>
    }
<span class="nc" id="L84">    File pf = new File(filepath);</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">    if (!pf.exists()) {</span>
<span class="nc" id="L86">      throw new IllegalArgumentException(&quot;Cannot find properties file &quot; + filepath);</span>
    }
<span class="nc" id="L88">    Properties properties = new Properties();</span>

<span class="nc" id="L90">    Closer closer = Closer.create();</span>
    try {
<span class="nc" id="L92">      FileReader reader = closer.register(new FileReader(pf));</span>
<span class="nc" id="L93">      properties.load(reader);</span>
    } finally {
<span class="nc" id="L95">      closer.close();</span>
    }
<span class="nc" id="L97">    return properties;</span>
  }

  /**
   * Reads and casts the named property as an Double.
   *
   * @param p The properties file to read from.
   * @param key To read the value of.
   * @param exceptionForNull If true, and the property is not found an IAE is thrown, otherwise defaultValue is
   *        returned
   * @param defaultValue If the property is not found, and exceptionForNull is false, this is returned for missing
   *        properties.
   * @return The property at the key as an Double
   * @throws IllegalArgumentException if the property is invalid (can't be cast to a double) or not found and we are
   *         instructed to throw it.
   */
  public static Double propertyAsDouble(Properties p, String key, boolean exceptionForNull, Double defaultValue)
    throws IllegalArgumentException {
<span class="nc" id="L115">    String v = p.getProperty(key);</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">    if (v != null) {</span>
      try {
<span class="nc" id="L118">        return Double.parseDouble(v);</span>
<span class="nc" id="L119">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L120">        throw new IllegalArgumentException(&quot;Invalid value[&quot; + v + &quot;] supplied for &quot; + key);</span>
      }
    } else {
<span class="nc bnc" id="L123" title="All 2 branches missed.">      if (exceptionForNull) {</span>
<span class="nc" id="L124">        throw new IllegalArgumentException(&quot;Missing property for &quot; + key);</span>
      } else {
<span class="nc" id="L126">        return defaultValue;</span>
      }
    }
  }

  /**
   * Reads and casts the named property as an Float.
   *
   * @param p The properties file to read from.
   * @param key To read the value of.
   * @param exceptionForNull If true, and the property is not found an IAE is thrown, otherwise defaultValue is
   *        returned
   * @param defaultValue If the property is not found, and exceptionForNull is false, this is returned for missing
   *        properties.
   * @return The property at the key as an Float
   * @throws IllegalArgumentException if the property is invalid (can't be cast to a float) or not found and we are
   *         instructed to throw it.
   */
  public static Float propertyAsFloat(Properties p, String key, boolean exceptionForNull, Float defaultValue)
    throws IllegalArgumentException {
<span class="nc" id="L146">    String v = p.getProperty(key);</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">    if (v != null) {</span>
      try {
<span class="nc" id="L149">        return Float.parseFloat(v);</span>
<span class="nc" id="L150">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L151">        throw new IllegalArgumentException(&quot;Invalid value[&quot; + v + &quot;] supplied for &quot; + key);</span>
      }
    } else {
<span class="nc bnc" id="L154" title="All 2 branches missed.">      if (exceptionForNull) {</span>
<span class="nc" id="L155">        throw new IllegalArgumentException(&quot;Missing property for &quot; + key);</span>
      } else {
<span class="nc" id="L157">        return defaultValue;</span>
      }
    }
  }

  /**
   * Reads and casts the named property as an Integer.
   *
   * @param p The properties file to read from.
   * @param key To read the value of.
   * @param exceptionForNull If true, and the property is not found an IAE is thrown, otherwise defaultValue is
   *        returned
   * @param defaultValue If the property is not found, and exceptionForNull is false, this is returned for missing
   *        properties.
   * @return The property at the key as an int
   * @throws IllegalArgumentException if the property is invalid (can't be cast to an int) or not found and we are
   *         instructed to throw it.
   */
  public static Integer propertyAsInt(Properties p, String key, boolean exceptionForNull, Integer defaultValue)
    throws IllegalArgumentException {
<span class="nc" id="L177">    String v = p.getProperty(key);</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">    if (v != null) {</span>
      try {
<span class="nc" id="L180">        return Integer.parseInt(v);</span>
<span class="nc" id="L181">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L182">        throw new IllegalArgumentException(&quot;Invalid value[&quot; + v + &quot;] supplied for &quot; + key);</span>
      }
    } else {
<span class="nc bnc" id="L185" title="All 2 branches missed.">      if (exceptionForNull) {</span>
<span class="nc" id="L186">        throw new IllegalArgumentException(&quot;Missing property for &quot; + key);</span>
      } else {
<span class="nc" id="L188">        return defaultValue;</span>
      }
    }
  }


  /**
   * Reads and casts the named property as a boolean.
   * Case insensitive values for 'true', 'on', 'yes', 't' and 'y' return true values,
   * 'false', 'off', 'no', 'f' and 'n' return false.
   * Otherwise or in case of a missing property the default will be used.
   *
   * @param p The properties file to read from.
   * @param key To read the value of.
   * @param defaultValue If the property is not found this is returned for missing properties.
   * @return The property at the key as a boolean
   */
  public static boolean propertyAsBool(Properties p, String key, boolean defaultValue) {
<span class="fc" id="L206">    Boolean val = BooleanUtils.toBooleanObject(p.getProperty(key, null));</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">    return val == null ? defaultValue : val;</span>
  }

  /**
   * Reads and converts the named property as UTF8 bytes.
   *
   * @param p The properties file to read from.
   * @param key To read the value of.
   * @param exceptionForNull If true, and the property is not found an IAE is thrown, otherwise defaultValue is
   *        returned
   * @param defaultValue If the property is not found, and exceptionForNull is false, this is returned for missing
   *        properties.
   * @return The property at the key as byte[]t
   * @throws IllegalArgumentException if the property is not found and we are instructed to throw it.
   */
  public static byte[] propertyAsUTF8Bytes(Properties p, String key, boolean exceptionForNull, byte[] defaultValue)
    throws IllegalArgumentException {
<span class="nc" id="L224">    String v = p.getProperty(key);</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">    if (v != null) {</span>
      try {
<span class="nc" id="L227">        return v.getBytes(UTF8_ENCODING);</span>
<span class="nc" id="L228">      } catch (UnsupportedEncodingException e) {</span>
        // never one would hope
<span class="nc" id="L230">        throw new RuntimeException(&quot;System does not support &quot; + UTF8_ENCODING + &quot; encoding&quot;);</span>
      }
    } else {
<span class="nc bnc" id="L233" title="All 2 branches missed.">      if (exceptionForNull) {</span>
<span class="nc" id="L234">        throw new IllegalArgumentException(&quot;Missing property for &quot; + key);</span>
      } else {
<span class="nc" id="L236">        return defaultValue;</span>
      }
    }
  }

  /**
   * Filters and translates Properties with a prefix.
   * The resulting Properties will only include the properties that start with the provided prefix with that prefix
   * removed (e.g. myprefix.key1 will be returned as key1 if prefix = &quot;myprefix.&quot;)
   *
   * @param properties to filter and translate
   * @param prefix prefix used to filter the properties. (e.g. &quot;myprefix.&quot;)
   * @return new Properties object with filtered and translated properties. Never null.
   */
  public static Properties filterProperties(final Properties properties, String prefix) {
<span class="fc" id="L251">    Preconditions.checkNotNull(properties, &quot;Can't filter a null Properties&quot;);</span>
<span class="fc" id="L252">    Preconditions.checkState(StringUtils.isNotBlank(prefix), &quot;Can't filter using a blank prefix&quot;, properties);</span>

<span class="fc" id="L254">    Properties filtered = new Properties();</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">    for (String key : properties.stringPropertyNames()) {</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">      if (key.startsWith(prefix)) {</span>
<span class="fc" id="L257">        filtered.setProperty(key.substring(prefix.length()), properties.getProperty(key));</span>
      }
<span class="fc" id="L259">    }</span>
<span class="fc" id="L260">    return filtered;</span>
  }

  /**
   * Returns a new Properties object that contains only the elements where the key starts by the provided
   * prefix. The same keys will be used in the returned Properties.
   * @param original
   * @param prefix
   * @return
   */
  public static Properties subsetProperties(final Properties original, String prefix) {
<span class="fc" id="L271">    return propertiesByPrefix(original, prefix, false);</span>
  }

  /**
   * Remove properties from the original object and return the removed element(s) as new Properties object.
   * The same keys will be used in the returned Properties.
   * @param original original object in which the element will be removed if key starts with provided prefix.
   * @param prefix
   * @return
   */
  public static Properties removeProperties(final Properties original, String prefix) {
<span class="fc" id="L282">    return propertiesByPrefix(original, prefix, true);</span>
  }

  /**
   * Get a a new Properties object that only contains the elements that start with the prefix.
   * The same keys will be used in the returned Properties.
   * @param original
   * @param prefix
   * @param remove should the element(s) be removed from the original Properties object
   * @return
   */
  private static Properties propertiesByPrefix(final Properties original, String prefix, boolean remove) {
<span class="fc" id="L294">    Preconditions.checkNotNull(original, &quot;Can't filter a null Properties&quot;);</span>
<span class="fc" id="L295">    Preconditions.checkState(StringUtils.isNotBlank(prefix), &quot;Can't filter using a blank prefix&quot;, original);</span>

<span class="fc" id="L297">    Properties filtered = new Properties();</span>

<span class="fc bfc" id="L299" title="All 2 branches covered.">    if(original.isEmpty()){</span>
<span class="fc" id="L300">      return filtered;</span>
    }

<span class="fc" id="L303">    Iterator&lt;Object&gt; keysIt = original.keySet().iterator();</span>
    String key;
<span class="fc bfc" id="L305" title="All 2 branches covered.">    while (keysIt.hasNext()) {</span>
<span class="fc" id="L306">      key = String.valueOf(keysIt.next());</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">      if (key.startsWith(prefix)) {</span>
<span class="fc" id="L308">        filtered.setProperty(key, original.getProperty(key));</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">        if(remove){</span>
<span class="fc" id="L310">          keysIt.remove();</span>
        }
      }
    }
<span class="fc" id="L314">    return filtered;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>