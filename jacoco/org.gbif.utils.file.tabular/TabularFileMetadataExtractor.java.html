<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TabularFileMetadataExtractor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GBIF Common</a> &gt; <a href="index.source.html" class="el_package">org.gbif.utils.file.tabular</a> &gt; <span class="el_source">TabularFileMetadataExtractor.java</span></div><h1>TabularFileMetadataExtractor.java</h1><pre class="source lang-java linenums">/*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gbif.utils.file.tabular;

import org.gbif.utils.PreconditionUtils;
import org.gbif.utils.file.CharsetDetection;
import org.gbif.utils.file.UnknownCharsetException;

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static java.util.Collections.reverseOrder;
import static java.util.stream.Collectors.counting;
import static java.util.stream.Collectors.toSet;

/**
 * Utility class to extract metadata {@link TabularFileMetadata} from a tabular file.
 */
public class TabularFileMetadataExtractor {

<span class="fc" id="L57">  private static final Logger LOG = LoggerFactory.getLogger(TabularFileMetadataExtractor.class);</span>
  private static final int MAX_SAMPLE_SIZE = 15;

  // This needs to be large enough to stumble upon a non-ASCII character.
  private static final int CHARSET_DETECTION_BUFFER_LENGTH = 1024 * 1024;

  private TabularFileMetadataExtractor() {}

<span class="fc" id="L65">  private static final Character[] POTENTIAL_DELIMITER_CHAR = {',', '\t', ';', '|'};</span>
<span class="fc" id="L66">  private static final Character[] POTENTIAL_QUOTES_CHAR = {'&quot;', '\''};</span>

<span class="fc" id="L68">  private static final Predicate&lt;LineDelimiterStats&gt; CONTAINS_FREQUENCY =</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">      lineStats -&gt; lineStats.getFrequency() &gt; 0;</span>
  private static final Comparator&lt;Map.Entry&lt;Character, Long&gt;&gt; BY_VALUE_LONG_DESC =
<span class="fc" id="L71">      Map.Entry.comparingByValue(reverseOrder());</span>
<span class="fc" id="L72">  private static final BiFunction&lt;Character, Character, Pattern&gt; COMPILE_QUOTE_PATTERN_FCT =</span>
      (delimiter, quoteChar) -&gt;
<span class="fc" id="L74">          Pattern.compile(&quot;[&quot; + delimiter + &quot;][ ]*[&quot; + quoteChar + &quot;][ ]*[^&quot; + delimiter + &quot;]&quot;);</span>

  /**
   * Extract metadata from a tabular file using a sample (defined by {@link #MAX_SAMPLE_SIZE}) of the file.
   * The extraction process is based on the frequency of character in the sample using 3 different approaches.
   * The method will not return any default value if no delimiter and/or quote character can be found in the sample.
   * The caller should decide which default values should be used to read the file.
   *
   * @param filePath a {@link Path} pointing to a file (not a folder).
   * @return new {@link TabularFileMetadata}, never null (but the content can be null).
   * @throws IOException
   * @throws UnknownCharsetException
   */
  public static TabularFileMetadata extractTabularFileMetadata(Path filePath)
      throws IOException, UnknownCharsetException {
<span class="fc" id="L89">    Objects.requireNonNull(filePath, &quot;filePath shall be provided&quot;);</span>
<span class="fc" id="L90">    PreconditionUtils.checkArgument(</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">        !Files.isDirectory(filePath), &quot;filePath should point to a file, not a directory&quot;);</span>

    Charset encoding;
    try {
<span class="fc" id="L95">      encoding =</span>
<span class="fc" id="L96">          CharsetDetection.detectEncoding(filePath.toFile(), CHARSET_DETECTION_BUFFER_LENGTH);</span>
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">      if (encoding == null) {</span>
<span class="nc" id="L98">        throw new UnknownCharsetException(&quot;Unable to detect the file's character encoding&quot;);</span>
      }
<span class="nc" id="L100">    } catch (IOException e) {</span>
<span class="nc" id="L101">      throw new UnknownCharsetException(e);</span>
<span class="fc" id="L102">    }</span>

    // open a first stream to read a sample of the file
<span class="fc" id="L105">    List&lt;String&gt; lines = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L106">    try (BufferedReader bf = Files.newBufferedReader(filePath, encoding)) {</span>
      String line;
      do {
<span class="fc" id="L109">        line = bf.readLine();</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">        if (line != null) {</span>
<span class="fc" id="L111">          lines.add(line);</span>
        }
<span class="fc bfc" id="L113" title="All 4 branches covered.">      } while (line != null &amp;&amp; lines.size() &lt; MAX_SAMPLE_SIZE);</span>
    }
<span class="fc" id="L115">    TabularFileMetadata tabularFileMetadata = extractTabularMetadata(lines);</span>
<span class="fc" id="L116">    tabularFileMetadata.setEncoding(encoding);</span>
<span class="fc" id="L117">    return tabularFileMetadata;</span>
  }

  /**
   * Tries to extract the {@link TabularFileMetadata} from a sample of lines of a tabular file.
   *
   * @param sample
   * @return new {@link TabularFileMetadata}, never null (but the content can be null).
   */
  static TabularFileMetadata extractTabularMetadata(final List&lt;String&gt; sample) {
<span class="fc" id="L127">    Objects.requireNonNull(sample, &quot;sample shall be provided&quot;);</span>
<span class="fc" id="L128">    TabularFileMetadata tabularFileMetadata = new TabularFileMetadata();</span>

<span class="fc" id="L130">    Optional&lt;Character&gt; delimiterFound = getDelimiterChar(sample);</span>
<span class="fc" id="L131">    final Character delimiter = delimiterFound.orElse(null);</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">    if (delimiter == null) {</span>
<span class="nc" id="L133">      return tabularFileMetadata;</span>
    }

<span class="fc" id="L136">    Optional&lt;Character&gt; quoteFound =</span>
<span class="fc" id="L137">        getHighestCountOf(sample, line -&gt; getQuoteCharWithHighestCount(line, delimiter));</span>
<span class="fc" id="L138">    final Character quote = quoteFound.orElse(null);</span>

<span class="fc" id="L140">    tabularFileMetadata.setDelimiter(delimiter);</span>
<span class="fc" id="L141">    tabularFileMetadata.setQuotedBy(quote);</span>

<span class="fc" id="L143">    return tabularFileMetadata;</span>
  }

  /**
   * Extract a character from a line using the given function.
   * Return the character with the highest counts.
   *
   * @param sample
   * @param characterExtractor function to apply on each line to extract a character
   *
   * @return
   */
  private static Optional&lt;Character&gt; getHighestCountOf(
      final List&lt;String&gt; sample, final Function&lt;String, Optional&lt;Character&gt;&gt; characterExtractor) {

    // remove Optional wrapper and ignore Optional.empty
<span class="fc" id="L159">    return sample.stream()</span>
<span class="fc" id="L160">        .map(characterExtractor)</span>
<span class="fc" id="L161">        .flatMap(</span>
            o -&gt;
<span class="fc" id="L163">                o.map(Stream::of)</span>
<span class="fc" id="L164">                    .orElseGet(Stream::empty)) // remove Optional wrapper and ignore Optional.empty</span>
<span class="fc" id="L165">        .collect(Collectors.groupingBy(Function.identity(), counting()))</span>
<span class="fc" id="L166">        .entrySet()</span>
<span class="fc" id="L167">        .stream()</span>
<span class="fc" id="L168">        .min(BY_VALUE_LONG_DESC)</span>
<span class="fc" id="L169">        .map(Map.Entry::getKey);</span>
  }

  /**
   * Given a sample of line, this method tries to determine the delimiter char used.
   *
   * @param sample
   *
   * @return the determined delimiter or Optional.empty if it can not be determined.
   */
  public static Optional&lt;Character&gt; getDelimiterChar(final List&lt;String&gt; sample) {

    // count the frequency of all possible delimiter for each lines
<span class="fc" id="L182">    List&lt;LineDelimiterStats&gt; linesStats = computeLineDelimiterStats(sample);</span>

    // get the distinct set of frequency for each delimiters to check the &quot;stability&quot;
<span class="fc" id="L185">    Map&lt;Character, Set&lt;Integer&gt;&gt; delimiterDistinctFrequency =</span>
<span class="fc" id="L186">        computeDelimiterDistinctFrequency(linesStats).entrySet().stream()</span>
            // filter out delimiter that we never saw
<span class="fc bfc" id="L188" title="All 4 branches covered.">            .filter(entry -&gt; entry.getValue().size() &gt; 1 || !entry.getValue().contains(0))</span>
<span class="fc" id="L189">            .sorted(Comparator.comparing(e -&gt; e.getValue().size()))</span>
<span class="fc" id="L190">            .collect(</span>
<span class="fc" id="L191">                Collectors.toMap(</span>
<span class="nc" id="L192">                    Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e2, LinkedHashMap::new));</span>

    // we can have more than one
<span class="fc" id="L195">    Set&lt;Character&gt; mostStableDelimiter =</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">        getAllEqualsToFirst(delimiterDistinctFrequency, (s1, s2) -&gt; s1.size() == s2.size());</span>

    // get the most used delimiter to check the &quot;overall usage&quot;
<span class="fc" id="L199">    Map&lt;Character, Integer&gt; delimiterFrequencySums =</span>
<span class="fc" id="L200">        computeDelimiterFrequencySums(linesStats).entrySet().stream()</span>
<span class="fc" id="L201">            .sorted(Map.Entry.&lt;Character, Integer&gt;comparingByValue().reversed())</span>
<span class="fc" id="L202">            .collect(</span>
<span class="fc" id="L203">                Collectors.toMap(</span>
<span class="nc" id="L204">                    Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e2, LinkedHashMap::new));</span>

<span class="fc" id="L206">    Set&lt;Character&gt; mostFrequentDelimiter =</span>
<span class="fc" id="L207">        getAllEqualsToFirst(delimiterFrequencySums, Integer::equals);</span>

    // get the highest frequency per line to check for &quot;usage per line&quot;
<span class="fc" id="L210">    Map&lt;Character, Long&gt; delimiterHighestFrequencyPerLine =</span>
<span class="fc" id="L211">        computeDelimiterHighestFrequencyPerLine(sample).entrySet().stream()</span>
<span class="fc" id="L212">            .sorted(Map.Entry.&lt;Character, Long&gt;comparingByValue().reversed())</span>
<span class="fc" id="L213">            .collect(</span>
<span class="fc" id="L214">                Collectors.toMap(</span>
<span class="nc" id="L215">                    Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e2, LinkedHashMap::new));</span>
<span class="fc" id="L216">    Set&lt;Character&gt; mostFrequentDelimiterPerLine =</span>
<span class="fc" id="L217">        getAllEqualsToFirst(delimiterHighestFrequencyPerLine, Long::equals);</span>

    // summary
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L221">      LOG.debug(&quot;delimiterDistinctFrequency -&gt; &quot; + delimiterDistinctFrequency);</span>
<span class="nc" id="L222">      LOG.debug(&quot;mostStableDelimiter -&gt; &quot; + mostStableDelimiter);</span>
<span class="nc" id="L223">      LOG.debug(&quot;delimiterFrequencySums -&gt; &quot; + delimiterFrequencySums);</span>
<span class="nc" id="L224">      LOG.debug(&quot;mostFrequentDelimiter -&gt; &quot; + mostFrequentDelimiter);</span>
<span class="nc" id="L225">      LOG.debug(&quot;delimiterHighestFrequencyPerLine-&gt;&quot; + delimiterHighestFrequencyPerLine);</span>
<span class="nc" id="L226">      LOG.debug(&quot;mostFrequentDelimiterPerLine -&gt;&quot; + mostFrequentDelimiterPerLine);</span>
    }

    // if the most stable is also the one that is used to most within the sample
<span class="fc" id="L230">    Optional&lt;Character&gt; resultCharacter =</span>
<span class="fc" id="L231">        intersectSingle(mostStableDelimiter, mostFrequentDelimiter);</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">    if (resultCharacter.isPresent()) {</span>
<span class="fc" id="L233">      return resultCharacter;</span>
    }

    // otherwise, if the most stable is also the most used based on lines
<span class="fc" id="L237">    resultCharacter = intersectSingle(mostStableDelimiter, mostFrequentDelimiterPerLine);</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">    if (resultCharacter.isPresent()) {</span>
<span class="fc" id="L239">      return resultCharacter;</span>
    }

    // as last resort if the most frequent delimiter overall and by line is the same
<span class="nc" id="L243">    resultCharacter = intersectSingle(mostFrequentDelimiter, mostFrequentDelimiterPerLine);</span>

<span class="nc" id="L245">    return resultCharacter;</span>
  }

  /**
   * Return the {@link Character} represents the intersection between 2 sets only if the resulting set represents
   * a single element.
   * @param set1
   * @param set2
   * @return
   */
  private static Optional&lt;Character&gt; intersectSingle(Set&lt;Character&gt; set1, Set&lt;Character&gt; set2) {
<span class="fc" id="L256">    Set&lt;Character&gt; intersection = new HashSet&lt;&gt;(set1);</span>
<span class="fc" id="L257">    intersection.retainAll(set2);</span>

<span class="fc bfc" id="L259" title="All 2 branches covered.">    return intersection.size() == 1 ? intersection.stream().findFirst() : Optional.empty();</span>
  }

  /**
   * Given a {@link Map}, return all elements that are equals to the first element (including itself)
   * based on the provided equals function.
   * @param map
   * @param equalsPredicate
   * @param &lt;T&gt;
   * @return all elements that are equals to the first one or an empty set if the map is empty
   */
  private static &lt;T&gt; Set&lt;Character&gt; getAllEqualsToFirst(
      Map&lt;Character, T&gt; map, BiFunction&lt;T, T, Boolean&gt; equalsPredicate) {

<span class="fc" id="L273">    Optional&lt;Map.Entry&lt;Character, T&gt;&gt; firstMapEntry = map.entrySet().stream().findFirst();</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">    if (!firstMapEntry.isPresent()) {</span>
<span class="nc" id="L275">      return Collections.EMPTY_SET;</span>
    }

<span class="fc" id="L278">    final T firstValue = firstMapEntry.get().getValue();</span>
<span class="fc" id="L279">    return map.entrySet().stream()</span>
<span class="fc" id="L280">        .filter(e -&gt; equalsPredicate.apply(firstValue, e.getValue()))</span>
<span class="fc" id="L281">        .map(Map.Entry::getKey)</span>
<span class="fc" id="L282">        .collect(Collectors.toSet());</span>
  }

  /**
   * For each element(line) of the sample, compute a {@link LineDelimiterStats} for each delimiter.
   * Note: delimiter that are not used within a line will be included with the frequency 0.
   * @param sample
   * @return new List, never null
   */
  static List&lt;LineDelimiterStats&gt; computeLineDelimiterStats(List&lt;String&gt; sample) {
<span class="fc" id="L292">    return sample.stream()</span>
<span class="fc" id="L293">        .map(TabularFileMetadataExtractor::lineToLineDelimiterStats)</span>
<span class="fc" id="L294">        .flatMap(List::stream)</span>
<span class="fc" id="L295">        .collect(Collectors.toList());</span>
  }

  /**
   * Compute the stats for each potential delimiters on a line.
   * @param line
   * @return
   */
  private static List&lt;LineDelimiterStats&gt; lineToLineDelimiterStats(String line) {
<span class="fc" id="L304">    return Arrays.stream(POTENTIAL_DELIMITER_CHAR)</span>
<span class="fc" id="L305">        .map(</span>
            delimiter -&gt;
<span class="fc" id="L307">                new LineDelimiterStats(delimiter, StringUtils.countMatches(line, delimiter)))</span>
<span class="fc" id="L308">        .collect(Collectors.toList());</span>
  }

  /**
   * For each {@link LineDelimiterStats}, collect the distinct frequency (count) of each delimiter.
   * This gives us an idea of the &quot;stability&quot; of each delimiter across the sample.
   * Note that since quotes are not handled, noise can be introduced if a quoted cells use the delimiter.
   *
   * See unit test for examples of when this method will be affected by noise.
   *
   * The most stable delimiter is normally defined by the {@link Character} returned by the methods where
   * the list of distinct frequency is the smallest in size excluding cases where the list contains only the element
   * representing 0 as Integer (which means the delimiter was never used).
   *
   * @param linesStats
   *
   * @return
   */
  static Map&lt;Character, Set&lt;Integer&gt;&gt; computeDelimiterDistinctFrequency(
      List&lt;LineDelimiterStats&gt; linesStats) {
<span class="fc" id="L328">    return linesStats.stream()</span>
<span class="fc" id="L329">        .collect(</span>
<span class="fc" id="L330">            Collectors.groupingBy(</span>
                LineDelimiterStats::getDelimiter,
<span class="fc" id="L332">                Collectors.mapping(LineDelimiterStats::getFrequency, toSet())));</span>
  }

  /**
   * For each line, check the delimiter that is used the most.
   * Return the count of each delimiter.
   * @param lines
   * @return
   */
  static Map&lt;Character, Long&gt; computeDelimiterHighestFrequencyPerLine(List&lt;String&gt; lines) {
<span class="fc" id="L342">    return lines.stream()</span>
<span class="fc" id="L343">        .map(TabularFileMetadataExtractor::getDelimiterWithHighestCount2)</span>
<span class="fc" id="L344">        .flatMap(</span>
            o -&gt;
<span class="fc" id="L346">                o.map(Stream::of)</span>
<span class="fc" id="L347">                    .orElseGet(Stream::empty)) // remove Optional wrapper and ignore Optional.empty</span>
<span class="fc" id="L348">        .collect(Collectors.groupingBy(LineDelimiterStats::getDelimiter, counting()));</span>
  }

  /**
   * For {@link LineDelimiterStats}, sum the frequency (count) of each delimiter.
   * This gives us an idea of the overall usage of each delimiter across the sample.
   * Note that since quotes are not handled, noise can be introduced if a quoted cell uses the delimiter.
   *
   * See unit test for examples of when this method will be affected by noise.
   *
   * @param linesStats
   *
   * @return
   */
  static Map&lt;Character, Integer&gt; computeDelimiterFrequencySums(
      List&lt;LineDelimiterStats&gt; linesStats) {
<span class="fc" id="L364">    return linesStats.stream()</span>
<span class="fc" id="L365">        .filter(CONTAINS_FREQUENCY)</span>
<span class="fc" id="L366">        .collect(</span>
<span class="fc" id="L367">            Collectors.groupingBy(</span>
                LineDelimiterStats::getDelimiter,
<span class="fc" id="L369">                Collectors.summingInt(LineDelimiterStats::getFrequency)));</span>
  }

  /**
   * Given a line, get the delimiter with the highest count if any can be found.
   * Note: quotes are ignored in the count so a delimiter used inside quotes will be counted.
   *
   * @param line line of text to analyse
   *
   * @return
   */
  static Optional&lt;Character&gt; getDelimiterWithHighestCount(String line) {
<span class="fc" id="L381">    int highestCount = 0;</span>
<span class="fc" id="L382">    Character highestCountDelimiter = null;</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">    for (Character delimiter : POTENTIAL_DELIMITER_CHAR) {</span>
<span class="fc" id="L384">      int currentCount = StringUtils.countMatches(line, delimiter);</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">      if (currentCount &gt; highestCount) {</span>
<span class="fc" id="L386">        highestCount = currentCount;</span>
<span class="fc" id="L387">        highestCountDelimiter = delimiter;</span>
      }
    }
<span class="fc" id="L390">    return Optional.ofNullable(highestCountDelimiter);</span>
  }

  static Optional&lt;LineDelimiterStats&gt; getDelimiterWithHighestCount2(String line) {
<span class="fc" id="L394">    int highestCount = 0;</span>
    // Character highestCountDelimiter = null;
<span class="fc" id="L396">    LineDelimiterStats lineDelimiterStats = null;</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">    for (Character delimiter : POTENTIAL_DELIMITER_CHAR) {</span>
<span class="fc" id="L398">      int currentCount = StringUtils.countMatches(line, delimiter);</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">      if (currentCount &gt; highestCount) {</span>
<span class="fc" id="L400">        highestCount = currentCount;</span>
<span class="fc" id="L401">        lineDelimiterStats = new LineDelimiterStats(delimiter, highestCount);</span>
      }
    }
<span class="fc" id="L404">    return Optional.ofNullable(lineDelimiterStats);</span>
  }

  /**
   * Given a line and a delimiter, try to determine the quoting character if any can be found.
   * To check if a quote character is used we run a regex to check for a delimiter followed by a quoting character.
   *
   * @param line line of text to analyse
   * @param delimiter delimiter used in the line of text
   *
   * @return
   */
  static Optional&lt;Character&gt; getQuoteCharWithHighestCount(String line, Character delimiter) {
<span class="fc" id="L417">    int highestCount = 0;</span>
<span class="fc" id="L418">    Character highestCountQuoteChar = null;</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">    for (Character quoteChar : POTENTIAL_QUOTES_CHAR) {</span>
<span class="fc" id="L420">      int currentCount = 0;</span>
<span class="fc" id="L421">      Matcher m = COMPILE_QUOTE_PATTERN_FCT.apply(delimiter, quoteChar).matcher(line);</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">      while (m.find()) {</span>
<span class="fc" id="L423">        currentCount++;</span>
      }
<span class="fc bfc" id="L425" title="All 2 branches covered.">      if (currentCount &gt; highestCount) {</span>
<span class="fc" id="L426">        highestCount = currentCount;</span>
<span class="fc" id="L427">        highestCountQuoteChar = quoteChar;</span>
      }
    }
<span class="fc" id="L430">    return Optional.ofNullable(highestCountQuoteChar);</span>
  }

  /**
   * Inner representation of stats (frequency) of a delimiter
   */
  static class LineDelimiterStats {
    private Character delimiter;
    private int frequency;

<span class="fc" id="L440">    LineDelimiterStats(Character delimiter, int frequency) {</span>
<span class="fc" id="L441">      this.delimiter = delimiter;</span>
<span class="fc" id="L442">      this.frequency = frequency;</span>
<span class="fc" id="L443">    }</span>

    Character getDelimiter() {
<span class="fc" id="L446">      return delimiter;</span>
    }

    int getFrequency() {
<span class="fc" id="L450">      return frequency;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>