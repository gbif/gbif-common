/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gbif.utils.file.csv;

import org.gbif.utils.collection.IterableUtils;
import org.gbif.utils.file.FileUtils;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class CSVReaderTest {

  private static final String UTF8 = StandardCharsets.UTF_8.name();

  @Test
  public void testCsvAlwaysQuotes() throws IOException {
    File csv = FileUtils.getClasspathFile("csv/csv_always_quoted.csv");
    try (CSVReader reader = new CSVReader(csv, "utf8", ",", '"', 1)) {
      String[] rec = reader.next();
      rec = reader.next();
      assertEquals("18728553", rec[0]);
      assertEquals("-0.25864171259110291", rec[6]);
      assertEquals("Martins Wood, Ightham", rec[10]);
    }
  }

  @Test
  public void testCsvQuotedDelimiter() throws IOException {
    String rows =
        "12,\"not real\"\n"
            + "13,not \"real\"\n"
            + "\"14\",noting\n"
            + "15,\"not \"\"real\"\"\"\n"
            + "16,\"no, this is \"\"real\"\"\"\n";

    InputStream stream = new ByteArrayInputStream(rows.getBytes(StandardCharsets.UTF_8));
    CSVReader reader = new CSVReader(stream, UTF8, ",", '"', 0);

    String[] rec = reader.next();
    assertEquals(2, rec.length);
    assertEquals("12", rec[0]);
    assertEquals("not real", rec[1]);

    rec = reader.next();
    assertEquals(2, rec.length);
    assertEquals("13", rec[0]);
    assertEquals("not \"real\"", rec[1]);

    rec = reader.next();
    assertEquals(2, rec.length);
    assertEquals("14", rec[0]);
    assertEquals("noting", rec[1]);

    rec = reader.next();
    assertEquals(2, rec.length);
    assertEquals("15", rec[0]);
    assertEquals("not \"real\"", rec[1]);

    rec = reader.next();
    assertEquals(2, rec.length);
    assertEquals("16", rec[0]);
    assertEquals("no, this is \"real\"", rec[1]);

    assertFalse(reader.hasNext());
  }

  /**
   * csv file with optional quotes generated by excel.
   * single, double quotes and comma within a field are tested.
   */
  @Test
  public void testCsvOptionalQuotes() throws IOException {
    File csv = FileUtils.getClasspathFile("csv/csv_optional_quotes_excel2008.csv");
    CSVReader reader = new CSVReader(csv, UTF8, ",", '"', 1);

    String[] atom = reader.next();
    assertEquals(3, atom.length);
    assertEquals("1", atom[0]);
    assertEquals("This has a, comma", atom[2]);

    atom = reader.next();
    assertEquals("I say this is only a \"quote\"", atom[2]);

    atom = reader.next();
    assertEquals("What though, \"if you have a quote\" and a comma", atom[2]);

    atom = reader.next();
    assertEquals("What, if we have a \"quote, which has a comma, or 2\"", atom[2]);

    reader.close();
  }

  /**
   * tests the csv reader with different number of header rows on the same file and compares the 4th line in the text
   * file for each of them
   */
  @Test
  public void testHeaderRows() throws IOException {
    File source = FileUtils.getClasspathFile("csv/iucn100.csv");
    // assert the headers are the same, no matter how many rows we skip for the iterator
    CSVReader reader = new CSVReader(source, UTF8, ",", '"', 1);
    reader.next();
    reader.next();
    String[] row4h1 = reader.next();
    reader.close();

    reader = new CSVReader(source, UTF8, ",", '"', 0);
    reader.next();
    reader.next();
    reader.next();
    String[] row4h0 = reader.next();
    reader.close();

    reader = new CSVReader(source, UTF8, ",", '"', 3);
    String[] row4h3 = reader.next();
    reader.close();

    assertTrue(row4h0.length == row4h1.length);
    assertTrue(row4h0.length == row4h3.length);
    int idx = row4h0.length;
    while (idx > 0) {
      idx--;
      assertEquals(row4h0[idx], row4h1[idx]);
      assertEquals(row4h0[idx], row4h3[idx]);
    }
  }

  /**
   * Test if skip header rows is working with larger settings.
   */
  @Test
  public void testHeaderRows2() throws IOException {
    File source = FileUtils.getClasspathFile("csv/iucn100.csv");
    CSVReader reader = new CSVReader(source, UTF8, ",", '"', 7);
    for (String[] row : IterableUtils.iterable(reader)) {
      assertEquals("9", row[0]);
      assertEquals("Aaptosyax grypus Rainboth, 1991", row[1]);
      assertEquals("Actinopterygii", row[4]);
      break;
    }
  }

  @Test
  public void testIgnoreEmptyLines() throws IOException {
    File csv = FileUtils.getClasspathFile("csv/empty_line.tab");
    CSVReader reader = new CSVReader(csv, UTF8, "\t", null, 1);
    String[] ids = {"1", "5", "10", "12", "14", "20", "21", "", "30"};
    int row = 0;
    while (reader.hasNext()) {
      String[] rec = reader.next();
      assertEquals(ids[row], rec[0]);
      row++;
    }
    assertTrue(reader.getEmptyLines().size() > 1);
    assertTrue(reader.getEmptyLines().contains(6));
    assertTrue(reader.getEmptyLines().contains(12));
  }

  /**
   * Testing classic non quoted tab files with escaped \t tabs.
   */
  @Test
  public void testTab() throws IOException {
    // build archive from single tab file
    File source = FileUtils.getClasspathFile("csv/escapedTab.tab");
    CSVReader reader = new CSVReader(source, UTF8, "\t", null, 1);

    // there should be 8 rows, each with 58 columns
    String[] line;
    int lineCount = 0;
    while ((line = reader.next()) != null) {
      lineCount++;
    }
    assertEquals(8, lineCount);
  }

  /**
   * Test extracting a CSV file containing embedded JSON, which itself contains escaped quotes.
   *
   * JSON value like: { "test": "value, \"like\" this" }
   *
   * Would become in CSV: "{ ""test"": ""value, \""like\"" this"" }"
   */
  @Test
  public void testCsvJsonEscapedQuotes() throws IOException {
    File csv = FileUtils.getClasspathFile("csv/csv_json_escaped_quotes.csv");
    CSVReader reader = new CSVReader(csv, UTF8, ",", '"', 1);

    String[] atom = reader.next();
    assertEquals(71, atom.length);
    assertEquals("779", atom[0]);
    assertEquals("Cambridge, Cambridge", atom[62]);
    // Without the Java escapes: {"chronostratigraphy": "Cretaceous, Early Cretaceous, Albian - Late
    // Cretaceous, Cenomanian", "cataloguedescription": "Very worn vertebra. Old catalogue says
    // \"fragments of bone\".", "created": "2009-05-13", "barcode": "010039076", "project":
    // "eMesozoic", "determinationnames": "Ornithocheirus", "subdepartment": "Vertebrates",
    // "lithostratigraphy": "Selborne Group, Upper Greensand Formation, Cambridge Greensand Member",
    // "imagecategory": ["Register;Specimen"]}
    assertEquals(
        "{\"chronostratigraphy\": \"Cretaceous, Early Cretaceous, Albian - Late Cretaceous, Cenomanian\", \"cataloguedescription\": \"Very worn vertebra. Old catalogue says \\\"fragments of bone\\\".\", \"created\": \"2009-05-13\", \"barcode\": \"010039076\", \"project\": \"eMesozoic\", \"determinationnames\": \"Ornithocheirus\", \"subdepartment\": \"Vertebrates\", \"lithostratigraphy\": \"Selborne Group, Upper Greensand Formation, Cambridge Greensand Member\", \"imagecategory\": [\"Register;Specimen\"]}",
        atom[2]);

    reader.close();
  }
}
